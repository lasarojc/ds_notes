
<!doctype html>
<html lang="pt" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.2.8">
    
    
      
        <title>Arquiteturas - Notas em Sistemas Distribuídos</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.cb6bc1d0.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.39b8e14a.min.css">
        
          
          
          <meta name="theme-color" content="#546d78">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
      <link rel="stylesheet" href="../css/extra.css">
    
    
      
        
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-PJX835H7DP","lasarojc.github.org/dsnotes"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}),document.addEventListener("DOMContentSwitch",function(){ga("send","pageview",document.location.pathname)})</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="deep-orange">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#arquiteturas" class="md-skip">
          Ir para o conteúdo
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href=".." title="Notas em Sistemas Distribuídos" class="md-header-nav__button md-logo" aria-label="Notas em Sistemas Distribuídos">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      <div class="md-header-nav__ellipsis">
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            Notas em Sistemas Distribuídos
          </span>
        </div>
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            
              Arquiteturas
            
          </span>
        </div>
      </div>
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Buscar" placeholder="Buscar" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/lasarojc/ds_notes" title="Ir ao repositório" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Notas em Sistemas Distribuídos" class="md-nav__button md-logo" aria-label="Notas em Sistemas Distribuídos">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Notas em Sistemas Distribuídos
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lasarojc/ds_notes" title="Ir ao repositório" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Prefácio
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../intro/" class="md-nav__link">
        Introdução
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../basics/" class="md-nav__link">
        Fundamentos
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Arquiteturas
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Arquiteturas
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Índice">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Índice
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#componentes-e-conectores" class="md-nav__link">
    Componentes e Conectores
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#clienteservidor" class="md-nav__link">
    Cliente/Servidor
  </a>
  
    <nav class="md-nav" aria-label="Cliente/Servidor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sistemas-multi-camadas" class="md-nav__link">
    Sistemas multi-camadas
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#par-a-par-peer-to-peer-p2p" class="md-nav__link">
    Par-a-Par (Peer-to-Peer, P2P)
  </a>
  
    <nav class="md-nav" aria-label="Par-a-Par (Peer-to-Peer, P2P)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rede-sobreposta-overlay" class="md-nav__link">
    Rede Sobreposta (Overlay)
  </a>
  
    <nav class="md-nav" aria-label="Rede Sobreposta (Overlay)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rede-nao-estruturada" class="md-nav__link">
    Rede Não-Estruturada
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rede-estruturada" class="md-nav__link">
    Rede Estruturada
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#de-nao-estruturada-a-estruturada" class="md-nav__link">
    De não estruturada a estruturada
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tabelas-de-espalhamento-distribuidas-dht" class="md-nav__link">
    Tabelas de Espalhamento Distribuídas (DHT)
  </a>
  
    <nav class="md-nav" aria-label="Tabelas de Espalhamento Distribuídas (DHT)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#identificacao" class="md-nav__link">
    Identificação
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#divisao-da-carga" class="md-nav__link">
    Divisão da carga
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#roteamento" class="md-nav__link">
    Roteamento
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estudo-de-caso-chord" class="md-nav__link">
    Estudo de Caso: Chord
  </a>
  
    <nav class="md-nav" aria-label="Estudo de Caso: Chord">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#identificacao_1" class="md-nav__link">
    Identificação
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#divisao-de-carga" class="md-nav__link">
    Divisão de carga
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#roteamento_1" class="md-nav__link">
    Roteamento
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#churn" class="md-nav__link">
    Churn
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estudo-de-caso-dynamodb" class="md-nav__link">
    Estudo de Caso: DynamoDB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estudo-de-caso-cassandra" class="md-nav__link">
    Estudo de Caso: Cassandra
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#outros-exemplos" class="md-nav__link">
    Outros exemplos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hibridos" class="md-nav__link">
    Híbridos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arquitetura-orientada-a-microsservicos" class="md-nav__link">
    Arquitetura Orientada a Microsserviços
  </a>
  
    <nav class="md-nav" aria-label="Arquitetura Orientada a Microsserviços">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#monolitos" class="md-nav__link">
    Monolitos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#microsservicos" class="md-nav__link">
    Microsserviços
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#do-monolito-aos-microsservicos" class="md-nav__link">
    Do Monolito aos Microsserviços
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#outras-arquiteturas" class="md-nav__link">
    Outras arquiteturas
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#referencias" class="md-nav__link">
    Referências
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../comm/" class="md-nav__link">
        Comunicação
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../coord/" class="md-nav__link">
        Coordenação
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../time/" class="md-nav__link">
        Tempo
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../fault/" class="md-nav__link">
        Tolerância a Falhas
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../disdb/" class="md-nav__link">
        Bancos de Dados
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../disfs/" class="md-nav__link">
        Sistemas de Arquivos
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../tech/" class="md-nav__link">
        Tecnologias
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Índice">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Índice
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#componentes-e-conectores" class="md-nav__link">
    Componentes e Conectores
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#clienteservidor" class="md-nav__link">
    Cliente/Servidor
  </a>
  
    <nav class="md-nav" aria-label="Cliente/Servidor">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sistemas-multi-camadas" class="md-nav__link">
    Sistemas multi-camadas
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#par-a-par-peer-to-peer-p2p" class="md-nav__link">
    Par-a-Par (Peer-to-Peer, P2P)
  </a>
  
    <nav class="md-nav" aria-label="Par-a-Par (Peer-to-Peer, P2P)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rede-sobreposta-overlay" class="md-nav__link">
    Rede Sobreposta (Overlay)
  </a>
  
    <nav class="md-nav" aria-label="Rede Sobreposta (Overlay)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rede-nao-estruturada" class="md-nav__link">
    Rede Não-Estruturada
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rede-estruturada" class="md-nav__link">
    Rede Estruturada
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#de-nao-estruturada-a-estruturada" class="md-nav__link">
    De não estruturada a estruturada
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tabelas-de-espalhamento-distribuidas-dht" class="md-nav__link">
    Tabelas de Espalhamento Distribuídas (DHT)
  </a>
  
    <nav class="md-nav" aria-label="Tabelas de Espalhamento Distribuídas (DHT)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#identificacao" class="md-nav__link">
    Identificação
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#divisao-da-carga" class="md-nav__link">
    Divisão da carga
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#roteamento" class="md-nav__link">
    Roteamento
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estudo-de-caso-chord" class="md-nav__link">
    Estudo de Caso: Chord
  </a>
  
    <nav class="md-nav" aria-label="Estudo de Caso: Chord">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#identificacao_1" class="md-nav__link">
    Identificação
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#divisao-de-carga" class="md-nav__link">
    Divisão de carga
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#roteamento_1" class="md-nav__link">
    Roteamento
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#churn" class="md-nav__link">
    Churn
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estudo-de-caso-dynamodb" class="md-nav__link">
    Estudo de Caso: DynamoDB
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estudo-de-caso-cassandra" class="md-nav__link">
    Estudo de Caso: Cassandra
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#outros-exemplos" class="md-nav__link">
    Outros exemplos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hibridos" class="md-nav__link">
    Híbridos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arquitetura-orientada-a-microsservicos" class="md-nav__link">
    Arquitetura Orientada a Microsserviços
  </a>
  
    <nav class="md-nav" aria-label="Arquitetura Orientada a Microsserviços">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#monolitos" class="md-nav__link">
    Monolitos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#microsservicos" class="md-nav__link">
    Microsserviços
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#do-monolito-aos-microsservicos" class="md-nav__link">
    Do Monolito aos Microsserviços
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#outras-arquiteturas" class="md-nav__link">
    Outras arquiteturas
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#referencias" class="md-nav__link">
    Referências
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              

<!-- Edit button -->


  <!--
       Hack: check whether the content contains a h1 headline. If it
       doesn't, the page title (or respectively site name) is used
       as the main headline.
    -->


  <!-- Content -->
  <h1 id="arquiteturas">Arquiteturas</h1>
<p>De acordo com David Garlan and Mary Shaw, January 1994, CMU-CS-94-166, em <a href="http://www.cs.cmu.edu/afs/cs/project/able/ftp/intro_softarch/intro_softarch.pdf"><em>An Introduction to Software Architecture</em></a></p>
<blockquote>
<p>... an architectural style determines the vocabulary of components and connectors that can be used in instances of that style, together with a set of constraints on how they can be combined. These can include topological constraints on architectural descriptions (e.g., no cycles). Other constraints—say, having to do with execution semantics—might also be part of the style definition.</p>
</blockquote>
<p>Em outras palavras, um estilo ou padrão arquitetural é o conjunto de princípios que provê uma infraestrutura abstrata para uma família de sistemas, e promove o reuso de projeto ao <a href="https://msdn.microsoft.com/en-us/library/ee658117.aspx">prover soluções para problemas recorrentes e frequentes</a> ao definir quais o <strong>componentes</strong> presentes no sistema e como estes interagem uns com os outros, por meio de <strong>conectores</strong>, para implementar a solução para um problema.</p>
<h2 id="componentes-e-conectores">Componentes e Conectores</h2>
<p>Para se alcançar eficiência no desenvolvimento de sistemas, é imperativo que se pare de reinventar a roda a cada iteração e, em vez disso, se reuse artefatos existentes, providos pela linguagem sendo usada, por <em>frameworks</em> de terceiros e por iterações anteriores da equipe. 
De fato, o desenvolvimento de novos sistemas deveria ser pautado pela criação de componentes simples e coesos, que possam ser operados independentemente e que por meio de interfaces bem especificadas completas, passam ser então conectados para resolver um problema maior.</p>
<p>Uma vez selecionados, os componentes são conectados por meio de conectores, que podem assumir múltiplas formas para esconder as complexas iterações entres os componentes, por exemplo, por meio de fluxos de mensagens ou invocações remotas de procedimentos.
Alguns conectores são complexos o suficiente para serem considerados eles próprios componentes, mas no contexto desta discussão, a bem da abstração, os consideraremos apenas como conectores. Por exemplo, um banco de dados usado para a comunicação entre dois processos é considerado um conector, e não um componente.</p>
<p>Componentes bem projetados, deveriam ser facilmente substituídos por outros que respeitem a conexão. Isto aumenta a manutenabilidade do sistemas e pode simplificar passos como a replicação de componentes.</p>
<div class="mermaid">graph LR
    A[Componente 1] --&gt; C{Conector} --&gt; B(Componente 2)</div>
<details class="todo"><summary>TODO</summary><p>desenhar o conector corretamente</p>
</details>
<p>Dependendo de como são conectados, haverá maior ou menor dependência entre os componentes.
Quando houver forte dependência, diremos que os componentes estão <strong>fortemente acoplados</strong> (<em>tightly coupled</em>). Caso contrário, diremos que estão <strong>fracamente acoplados</strong> (<em>loosely coupled</em>).
A razão óbvia para preferir sistemas fracamente conectados é sua capacidade de tolerar disrupções; se um componente depende pouco de outro, então não se incomodará com sua ausência por causa de uma falha.</p>
<p><img alt="https://dzone.com/articles/the-importance-of-loose-coupling-in-rest-api-desig" src="../images/loosetight.png" /></p>
<p>Certos <em>middleware</em> permitem um acoplamento tão fraco entre componentes, que estes não precisam se conhecer ou sequer estar ativos no mesmo momento.</p>
<p><img alt="Desacoplamento" src="../images/component2.png" /></p>
<p>Também a questão da simplificação de API, uma vez que o <em>middleware</em> pode impor um padrão a ser seguido por todos os componentes e minimizar a necessidade os componentes conhecerem as interfaces uns dos outros.</p>
<h2 id="clienteservidor">Cliente/Servidor</h2>
<p>A forma como os componentes se comunicam, isto é, os conectores usados, é importante no estudo arquitetural. 
Mas também são importantes os papéis assumidos pelos componentes na realização de tarefas.
Neste sentido, provavelmente a arquitetura de computação distribuída mais comum é a <strong>Cliente/Servidor</strong>.
Na arquitetura Cliente/Servidor, como implicado pelo nome, há um processo que serve a pedidos realizados por outros processos. 
Isto é feito quando o <strong>cliente</strong> o contacta o servidor e requer (<em>request</em>) a realização do serviço.
O <strong>servidor</strong>, por sua vez, pode desempenhar tarefas como fazer cálculos, armazenar dados, ou repassar uma mensagem e, ao final da realização da tarefa, responder (<em>response</em>) ao cliente.</p>
<p>Esta arquitetura forma a base da computação distribuída, sobre a qual todos os outros modelos são implementados.
Uma das razões é histórica: os primeiros sistemas a permitirem a operação por múltiplos usuários, ainda na década de 60, eram compostos de um <em>host</em> robusto ao qual se conectavam diversos terminais, essencialmente com teclado e monitor, isto é, um servidor e vários clientes.
Com a redução dos computadores, surgiram as primeiras redes de computadores e a necessidade de uma abstração para o estabelecimento de comunicação entre processos em hosts distintos, e assim surgiram os <strong>sockets</strong>.
Com os sockets, vem uma grande flexibilidade, pois um processo não precisa saber como o outro manuseia os dados que lhe cabem, desde que siga um protocolo pré-estabelecido na comunicação. Isto é, processos podem ser implementado em diferentes linguagens, sistemas operacionais e arquiteturas, desde observadas os cuidados necessários para se obter <a href="../intro/#transparencia">transparência de acesso</a>.
Esta flexibilidade é a outra razão do sucesso do modelo cliente/servidor, permitindo que clientes se conectem a servidores para usar seus recursos, que podem ser acessados concorrentemente por diversos clientes.</p>
<p><img alt="http://psspol.blogspot.com.br/2015/07/difference-between-client-server.html" src="../images/cs.png" /></p>
<p>Embora seja possível usar sockets de forma assíncrona, a API mais comum é síncrona, isto é, quando um processo espera receber uma mensagem de outro, ele fica bloqueado esperando algum dado estar disponível para leitura no referido socket.
De forma genérica, estas interações acontecem como na figura a seguir.</p>
<div class="mermaid">sequenceDiagram
    activate Servidor
    activate Cliente
    note left of Servidor: Cria socket e espera por conexões
    deactivate Servidor

    Cliente-&gt;&gt;+Servidor: Connect?
    note left of Servidor: Aceita conexão
    Servidor-&gt;&gt;-Cliente: Connect!



    note right of Cliente: Ativo (gerando requisição)
    note left of Servidor: Inativo (esperando requisição)
    Cliente-&gt;&gt;+Servidor: Request
    deactivate Cliente
    note right of Cliente: Inativo (esperando resposta)
    note left of Servidor: Ativo (processando requisição)
    Servidor--&gt;&gt;-Cliente: Response
    activate Cliente
    note right of Cliente: Ativo (processando resposta
    note left of Servidor: Inativo (esperando requisição)
    deactivate Cliente

    activate Cliente
    note right of Cliente: Ativo (gerando requisição)
    Cliente-&gt;&gt;+Servidor: Request
    deactivate Cliente
    note right of Cliente: Inativo (esperando resposta)
    note left of Servidor: Ativo (processando requisição)
    Servidor--&gt;&gt;-Cliente: Response
    activate Cliente
    note right of Cliente: Ativo (processando resposta
    note left of Servidor: Inativo (esperando requisição)
    deactivate Cliente</div>
<p>Observe que o cliente fica inativo enquanto espera a resposta e que o servidor fica inativo enquanto espera outras requisições.
Para minimizar os períodos de inatividade, o cliente pode usar o socket assíncronamente, o que não é exatamente simples, ou usar múltiplos threads, para que continue operando mesmo enquanto um thread estiver bloqueado esperando a resposta do servidor.</p>
<p>No lado do servidor, o minimização da ociosidade é feita pelo uso de múltiplos clientes, concorrentes, e também pelo uso de múltiplos threads.
Neste caso, contudo, é necessário tomar muito cuidado para garantir que a concorrência não causará efeitos indesejados nos dados e execução das tarefas.
Veja o caso de um banco de dados transacional, por exemplo, como discutido acima; ele precisa garantir ACID entre as transações propostas pelos clientes.</p>
<p>Exemplos desta arquitetura são abundantes, incluindo um navegador que se comunica com um servidor Apache para recuperar uma página Web ou em um aplicativo móvel que solicita ao servidor de aplicações que dispare uma transferência de fundos.</p>
<p>Embora tenhamos colocado aqui apenas um servidor atendendo aos clientes, em muitas aplicações modernas, múltiplos servidores atenderão ao conjunto de clientes.
Pense por exemplo no serviço de email do Google, o Gmail. Com os milhões de usuários que tem, certamente há mais de um servidor implementando o serviço.
Provavelmente estes diversos servidores ficam atrás do que chamamos de um balanceador de carga, que roteia as requisições seguindo diferentes políticas, por exemplo, <em>round robin</em>.</p>
<p><img alt="http://blogs.softchoice.com/itgrok/client/one-egg-many-baskets/" src="../images/lb.jpg" /></p>
<p>Exemplos cotidianos disto são servidores de bancos de dados, de páginas Web e email.
De fato, esta flexibilidade permite que diversas aplicações continuem operando de forma centralizada, com servidores rodando, por exemplo, em mainframes e clientes rodando de forma emulada por software em computadores pessoais.</p>
<p>Contudo, em certas situações, esta divisão entre clientes e servidores pode se tornar confusa.
Primeiro, por quê uma vez estabelecida a conexão, não há uma diferenciação entre quem iniciou e quem aceitou a mesma; são apenas duas pontas do mesmo socket.
Segundo, pode ser que o serviço relevante sendo prestado, seja prestado por quem estabelece a conexão. De fato ambos podem estar prestando serviços um para o outro, no que é conhecido como P2P.
Terceiro, um mesmo processo pode atuar tanto como cliente quanto como servidor, no que é conhecido como arquitetura multicamadas, também a ser visto adiante.
Quarto, usando-se sockets como base, podemos construir outros modelos de comunicação entre processos, efetivamente colocando camadas na nossa cebola.<sup id="fnref:shrek"><a class="footnote-ref" href="#fn:shrek">1</a></sup></p>
<p>A seguir, exploraremos as arquiteturas construídas sobre cliente/servidor.</p>
<h3 id="sistemas-multi-camadas">Sistemas multi-camadas</h3>
<p>Outra forma de hibridismo que podemos citar é quando um componente haje tanto como cliente quanto como servidor. 
Veja o seguinte exemplo, conhecido no meio como arquitetura em 3-camadas (3 <em>tiers</em>).</p>
<p><a href="https://managementmania.com/en/three-tier-architecture"><img alt="3 Tiers" src="../images/3tierb.gif" /></a></p>
<p>Neste caso, é interessante notar que esta disposição dos componentes é independente da disposição física. De fato, as três camadas podem estar em um mesmo nó, ou combinadas duas a duas, neste último caso resultando em duas camadas.</p>
<p><img alt="2 Tiers" src="../images/02-05.png" /></p>
<p>Por outro lado, cada camada pode ser subdividida em mais componentes, resultando em múltiplos tiers, como neste exemplo de um sistema de busca na Web.</p>
<p><img alt="Multi-tier" src="../images/02-04.png" /></p>
<h2 id="par-a-par-peer-to-peer-p2p">Par-a-Par (Peer-to-Peer, P2P)</h2>
<p>Diferentemente de sistemas cliente/servidor, em que um nó serve o outro, em sistemas par-a-par, os nós são parceiros e tem igual responsabilidade (e daí o nome) na execução das tarefas.</p>
<p>Como todo sistema distribuído, a arquitetura P2P visa <strong>agregar poder computacional de múltiplos nós</strong>.
Mas além disso, pelo não diferenciação dos componentes, espera-se <strong>tolerar falhas de componentes sem paralisar o serviço</strong>, uma vez que não há um componenente centralizador, detentor único de uma certa funcionalidade.
Os sistemas P2P tendem portanto a lever a maior disponibilidade.</p>
<p>Historicamente, e devido às características já mencionadas, os sistemas P2P tem outra característica muito importante, a <strong>alta escalabilidade</strong> a que se oferecerem, chegando a níveis globais.</p>
<p>Se pensarmos por exemplo nos sistemas de compartilhamento de arquivos, músicas e filmes, razão da fama e infâmia da arquitetura, teremos bons exemplos disso.
Para que isso seja possível, estes sistemas precisam se tornar <strong>auto-gerenciáveis</strong>, pois sistemas globais devem tolerar <strong>entrada e saída frequente de nós</strong> (por falhas ou ação de seus usuários), <strong>diferentes domínios administrativos</strong>, e heterogeneidade na comunicação.
Uma das ferramentas utilizadas para simplificar o trabalho de auto-gerenciamento é o conceito de <strong>redes sobrepostas</strong>.</p>
<p>Diversos sistemas P2P existem, sendo, provavelmente, os mais famosos, os sistemas de compartilhamento de arquivos, em que cada nó armazena e disponibiliza parte dos dados, bem como acessa os dados disponibilizados por outros nós.
Nesta linha, embora diversos tenham existido, hoje o mais famoso é o Bittorrent, mesmo que, como veremos adiante, não seja P2P puro.</p>
<p>Outro exemplo importante por ter inspirado diversos outros sistemas é o Chord. 
Neste sistema, nós organizam-se em um anel lógico e cada um se torna responsável por um dos segmentos do anel adjacente a onde se encontra no mesmo.
Requisições para correspondentes a um segmento são roteados para o nó responsável usando uma tabela de rotas conhecida como <em>finger table</em>.
Se traçarmos os caminhos apontados por esta tabela sobre o anel, desenharemos <strong>cordas</strong> sobre o mesmo, o que explica o nome do sistema.</p>
<p><img alt="Chord" src="../images/chord.png" /></p>
<h3 id="rede-sobreposta-overlay">Rede Sobreposta (<em>Overlay</em>)</h3>
<p>Os componentes de um sistema P2P se organizam em uma rede lógica, <strong>sobreposta</strong> à rede física.
Nesta rede lógica, os processos estabelecem canais de comunicação tipicamente na forma de conexões TCP/IP.
Por serem ignorantes à topologia física da rede e usarem a pilha de comunicação IP, as redes sobrepostas são mais simples e ao mesmo tempo mais poderosas. 
Nestas redes são executados diversos algoritmos, como de descoberta de nós, roteamento de pacotes e de otimização de rotas pelo descarte e criação de conexões.</p>
<p>Uma vez que as <strong>conexões na rede sobreposta não correspondem a conexões físicas</strong>, como se pode ver na seguinte figura, vizinhos em um rede sobreposta não necessariamente correspondem a vizinhos na rede física e vice-versa.
Isto também implica que a <strong>otimização da rota lógica não necessariamente leva à otimização da rota física</strong>.</p>
<p><a href="https://pt.wikipedia.org/wiki/Peer-to-peer#/media/Ficheiro:Overlay_p2p.jpg"><img alt="Por Gustavo Lacerda - UFRJ, Domínio público" src="../images/overlay.jpg" /></a></p>
<p>Dependendo em como esta rede é organizada (ou não), a mesma é classificada como <strong>estruturada</strong> ou <strong>não-estruturada</strong>.</p>
<h4 id="rede-nao-estruturada">Rede Não-Estruturada</h4>
<p>Se a rede sobreposta é construída de forma aleatória, por exemplo deixando os nós se conectarem apenas aos vizinhos na rede no ponto em que se conectaram inicialmente, então esta é denominada uma rede <strong>não-estruturada</strong>. 
A figura a seguir é um exemplo que se percebe que nós tem graus diferentes de conectividade e que não estão particularmente organizados em nenhuma topologia.</p>
<p><a href="http://gossple2.irisa.fr/~akermarr/LSDS-EPFL-unstructured.pdf"><img alt="Não-estruturada" src="../images/unstructured.png" /></a></p>
<p>Suponha que esta rede seja usada para armazenar e consultar dados.
Inserções de dados podem ser feitas muito rapidamente, armazenando-os no primeiro nó disponível encontrado.
Os objetos amarelo e vermelho foram inseridos desta forma, e copiados em nós próximos para tolerar a falha de alguns hosts sem perder os dados.
Buscas, contudo, terão que vasculhar a rede usando algoritmos como <strong>busca em largura</strong>, <strong>busca em profundidade</strong> ou <strong>caminhada aleatória</strong> (resposta probabilística).</p>
<h4 id="rede-estruturada">Rede Estruturada</h4>
<p>Se as conexões são construídas e mantidas de forma a gerar uma <strong>topologia bem definida</strong>, chamamos esta rede de <strong>estruturada</strong>.
Nesta rede, a inserção de nós requer a propagação desta informação para outros nós e a atualização das conexões para manter a estrutura.
A estrutura geralmente serve ao propósito de associar os nós aos dados de uma forma planejada. 
Por exemplo, nós próximos na rede podem ser responsáveis por dados logicamente próximos.
Claramente, a inserção e acesso a dados nesta rede é mais custosa, pois independentemente de onde a requisição é feita, isto é, a partir de qual nó, ela deverá ser atendida por um nó específico. </p>
<p>Veja o exemplo do Chord, uma rede P2P em que os nós formam um anel lógico, cujos detalhes veremos adiante.
Cada nó é responsável pela faixa de valores indexados por chaves entre o identificador do nó e o do nó anterior.
Logo, qualquer inserção ou consulta de dados, deve ser feita especificamente para um determinado nó, e deve ser <strong>roteada</strong> para o mesmo.
A estrutura da rede permite que tal roteamento seja feito eficientemente, no nível da rede sobreposta.</p>
<p><img alt="" src="../images/05-04.png" /></p>
<p>Como outro exemplo considere uma rede em que os nós armazenam informações sobre os dados de uma certa área geográfica e que nós vizinhos na rede sejam aqueles responsáveis por áreas que se tocam.</p>
<p><img alt="" src="../images/02-08.png" /></p>
<p>Neste exemplo, para se acessar os dados de um certo ponto no mapa, basta rotear a requisição para o vizinho mais próximo do ponto; necessariamente a requisição chegará ao nó correto.</p>
<h4 id="de-nao-estruturada-a-estruturada">De não estruturada a estruturada</h4>
<p>A seguinte tabela resume as diferenças entre os dois tipos de redes sobrepostas.</p>
<table>
<thead>
<tr>
<th>Estruturada</th>
<th>Não-Estruturada</th>
</tr>
</thead>
<tbody>
<tr>
<td>Estrutura bem definida</td>
<td>Estrutura aleatória</td>
</tr>
<tr>
<td>Adição de dados é lenta</td>
<td>Adição de dados é rápida</td>
</tr>
<tr>
<td>Adição de nós é lenta</td>
<td>Adição de nós é rápida</td>
</tr>
<tr>
<td>Busca por dados é rápida</td>
<td>Busca por dados lenta</td>
</tr>
</tbody>
</table>
<p>Mas, e se pudéssemos juntar o melhor dos dois mundos em um único sistema? Isso é possível em certos cenários. 
Por exemplo, seja uma grade <span class="arithmatex">\(N \times N\)</span> em que nós se conectam aleatoriamente uns aos outros, e que nós em uma borda da matriz conseguem se conectar aos nós da borda oposta, com distância 1.
Efetivamente, temos a rede sobreposta à esquerda.</p>
<p><img alt="" src="../images/02-11.png" /></p>
<p>Se cada nó executar o seguinte protocolo, a rede evoluirá da topologia não estruturada para a estruturada, à direita.</p>
<ul>
<li>Divida a organização da topologia em dois módulos, um de descoberta de novos nós e outro de seleção.<br />
<img alt="" src="../images/02-10.png" /></li>
<li>O módulo de descoberta, repetidamente, pergunta aos seus vizinhos quem são os seus vizinhos e se conecta aos mesmos.</li>
<li>O módulo de seleção computa a distância entre o nó e todos os seus vizinhos e descarta as conexões com maior distância, onde<ul>
<li><span class="arithmatex">\(a = (x,y), b = (x', y')\)</span></li>
<li><span class="arithmatex">\(dx_{a,b} = min(|x - x'|, N - |x - x'|)\)</span></li>
<li><span class="arithmatex">\(dy_{a,b} = min(|y - y'|, N - |y - y'|)\)</span></li>
</ul>
</li>
</ul>
<p>Ao final de múltiplas interações, cada nó terá como seus vizinhos, os nós mais próximos. Se a rede for completa (um nó em cada posição da grade), os vizinhos serão os nós à direita, esquerda, acima e abaixo.
A seguinte figura apresenta uma outra rede resultada da aplicação do mesmo princípio, mas em uma "grade" 3D.</p>
<p><a href="https://clusterdesign.org/torus/"><img alt="Fujitsu and RIKEN, 2009" src="../images/3d-torus.jpg" /></a></p>
<p>Se em vez da distância cartesiana fosse usada a distância de Hamming entre os identificadores dos nós, ao final das iterações, a topologia alcançada seria um hyper-cubo, como os da seguinte figura, no qual diversos <a href="https://en.wikipedia.org/wiki/Hypercube_internetwork_topology">esquemas de roteamento eficientes podem ser usados</a>.<sup id="fnref:icpc_hyper"><a class="footnote-ref" href="#fn:icpc_hyper">3</a></sup></p>
<p><a href="https://commons.wikimedia.org/w/index.php?curid=5071550"><img alt="By Spiritia" src="../images/hypercube.png" /></a></p>
<div class="admonition sideslide">
<p class="admonition-title">Sistemas P2P</p>
<ul>
<li>Arquitetura decentralizada;</li>
<li>Não há distinção de papéis entre nós ou conjuntos de nós desempenham os mesmos papéis, em parceria;</li>
<li>Escalabilidade geográfica global, isto é, com nós espalhados por todo o globo;</li>
<li>Pode haver entrada e saída de nós do sistema com alta frequência; </li>
<li>Nós se organizam em redes sobrepostas (em inglês, <em>overlay</em>), redes lógicas sobre as redes físicas;</li>
<li>Auto-administração.</li>
<li>Resiliente a falhas</li>
</ul>
</div>
<h3 id="tabelas-de-espalhamento-distribuidas-dht">Tabelas de Espalhamento Distribuídas (DHT)</h3>
<p>A versatilidade dos sistemas P2P os levaram a ser amplamente estudados e aplicados, sendo que entre as aplicações mais bem sucedidas estão as Tabelas de Espalhamento Distribuídas (DHT, do inglês, <em>Distributed Hash Tables</em>).</p>
<p>As tabelas de espalhamento (também conhecidas como mapas, dicionários, arrays associativos) tem características que a tornam adequadas ao armazenamento de dados a vários cenários.
Em essência, estas tabelas são funções que <strong>mapeiam</strong> uma chave para um valor, uma função <span class="arithmatex">\(f\)</span> tal que</p>
<ul>
<li><span class="arithmatex">\(f(K): V \cup\)</span> {null}</li>
<li><span class="arithmatex">\(K\)</span>: Universo de chaves</li>
<li><span class="arithmatex">\(V\)</span>: Universo de valores</li>
</ul>
<p>isto é, <span class="arithmatex">\(f(k) = v, k\in K, v \in V\)</span> ou <span class="arithmatex">\(v =\)</span> null.</p>
<p>Na prática, são estruturas de dados adaptáveis, com um API muito simples, e com operações de tempo (mais ou menos) constante para fazer CRUD de pares chave/valor.
Tanto <span class="arithmatex">\(K\)</span> quanto <span class="arithmatex">\(V\)</span> são <strong>blobs</strong> de dados, isto é, sem nenhuma forma distinta, e por isso podem ser usadas para resolver uma gama de problemas.</p>
<div class="admonition note">
<p class="admonition-title">API</p>
<ul>
<li><span class="arithmatex">\(put(k,v)\)</span>: if <span class="arithmatex">\(k \rightarrow w\)</span> then return <span class="arithmatex">\(w\)</span> else <span class="arithmatex">\(k \rightarrow v\)</span>; return <span class="arithmatex">\(\emptyset\)</span></li>
<li><span class="arithmatex">\(update(k,v)\)</span>: if <span class="arithmatex">\(k \rightarrow w\)</span> then return <span class="arithmatex">\(w\)</span> else return <span class="arithmatex">\(\emptyset\)</span></li>
<li><span class="arithmatex">\(get(k)\)</span>: if <span class="arithmatex">\(k \rightarrow w\)</span> then return <span class="arithmatex">\(w\)</span> else return <span class="arithmatex">\(\emptyset\)</span> </li>
<li><span class="arithmatex">\(del(k)\)</span>: if <span class="arithmatex">\(k \rightarrow w\)</span> then return <span class="arithmatex">\(w\)</span> else <span class="arithmatex">\(k \rightarrow v\)</span>; return <span class="arithmatex">\(\emptyset\)</span></li>
<li><span class="arithmatex">\(k\)</span> e <span class="arithmatex">\(v\)</span> são blobs</li>
<li>execução <span class="arithmatex">\(O(1)\)</span></li>
</ul>
</div>
<p>Se as tabelas de espalhamento são estruturas de dados úteis, uma versão distribuída seria ainda mais útil, principalmente porquê ela poderia ser <strong>tolerante a falhas</strong> e ter <strong>escalabilidade linear</strong>.
É justamente desta idea que surgem as DHT, literalmente tabelas de espalhamento distribuídas, estruturas de dados que mantém <strong>a mesma API</strong> e funcionalidades de tabelas de espalhamento, mas que <strong>agrega capacidades de diversos hosts</strong>.</p>
<p>Dentre os desafios na implementação de uma DHT estão</p>
<ul>
<li>O que usar como chave? Uma DHT deve ser versátil para ser utilizada para vários fins, então a chave precisa ser independente da aplicação.</li>
<li>Como dividir a carga entre hosts? É preciso balancear a carga para que um lado da rede não se torne mais importante que o outro e para não levar a uma hierarquização entre os nós.</li>
<li>Como rotear requisições para o host correto? Uma vez que os dados devem ser particionados entre hosts para garantir escalabilidade, como encontrar o nó onde determinado dado está or deveria estar?</li>
</ul>
<h4 id="identificacao">Identificação</h4>
<p>A identificação de objetos precisa ser facilmente <strong>determinável pela aplicação</strong> para permitir a recuperação precisa dos dados. 
Por exemplo, pode-se dividir faixas de nomes entre os processos.</p>
<ul>
<li>A -- C -- Host1</li>
<li>CA -- E -- Host2</li>
<li>EA -- G -- Host3</li>
<li>...</li>
</ul>
<p>Esta distribuição tem três problemas graves. O primeiro, é no fato de nomes não serem <strong>unívocos</strong>.
Neste caso, uma exemplo melhor seria o uso do CPF.</p>
<ul>
<li>000.000.000-00 -- 111.111.111-00 -- Host1</li>
<li>111.111.111-01 -- 222.222.222-00 -- Host2</li>
<li>222.222.222-01 -- 333.333.333-00 -- Host3</li>
<li>...</li>
</ul>
<p>O segundo problema, presente também no uso de CPF, tem a ver com a distribuição da carga de trabalho entre os hosts.
Nem nomes e nem CPF tem distribuição uniforme, então alguns nós ficariam mais carregados que outros.</p>
<p>O terceiro problema tem a ver com o uso de chaves não genéricas, dependentes da aplicação.
Para este problema, poderíamos usar um identificador auto-incrementável, por exemplo, mas em muitas situações esta abordagem implicaria em dificuldade para se recuperar os dados: "qual é mesmo o identificador numérico do livro <a href="https://ler.amazon.com.br/kp/embed?asin=B0796DNSVZ&amp;preview=newtab&amp;linkCode=kpe&amp;ref_=cm_sw_r_kb_dp_fAlUDbMBJM4RP">How Fascism Works</a>?"</p>
<p>Para resolver estes três problemas, recorremos a uma abordagem usada na literatura da área, dividindo a identificação em duas camadas:</p>
<ul>
<li>Seja <span class="arithmatex">\(i\)</span> o identificador do objeto, dado pela aplicação (e.g., CPF, nome, telefone)</li>
<li>Seja <span class="arithmatex">\(h\)</span> uma função criptográfica</li>
<li>Seja <span class="arithmatex">\(k = h(i)\)</span> o identificador do objeto <span class="arithmatex">\(i\)</span>.</li>
</ul>
<h4 id="divisao-da-carga">Divisão da carga</h4>
<p>Se usarmos, por exemplo, MD5, é fato que <span class="arithmatex">\(k\)</span> tem distribuição uniforme no espaço de 0 a <span class="arithmatex">\(2^{160}-1\)</span> possíveis valores.
Para dividirmos os dados entre os hosts também uniformemente, distribua os valores entre os hosts em função de <span class="arithmatex">\(k\)</span>.
Alguns exemplos de divisão são:</p>
<ul>
<li>defina <em>buckets</em> para cada host e atribua o dado com chave <span class="arithmatex">\(k\)</span> para bucket <span class="arithmatex">\(k \% b\)</span>, onde <span class="arithmatex">\(b\)</span> é o número de buckets</li>
<li>divida a faixa de valores em <span class="arithmatex">\(b\)</span> segmentos e atribua a cada host uma faixa</li>
<li>dados <span class="arithmatex">\(2^n\)</span> hosts, atribua ao host <span class="arithmatex">\(0 &lt; x &lt; 2^n-1\)</span> os dados cujas chaves terminem com o valor <span class="arithmatex">\(x\)</span>.</li>
</ul>
<p>São várias as formas de se dividir os dados e estas estão intimamente ligadas à rede sobreposta que se pretende montar e a como o roteamento será feito.</p>
<h4 id="roteamento">Roteamento</h4>
<p>Para estudar o desafio do roteamento, nas seções seguintes estudaremos o Chord, um sistema P2P que surgiu no meio acadêmico mas cujo design influenciou fortemente a indústria no desenvolvimento dos bancos dados distribuídos NOSQL, como Cassandra, Dynamo, e Redis.</p>
<h4 id="estudo-de-caso-chord">Estudo de Caso: Chord</h4>
<p>Chord é uma sistema P2P de múltiplas aplicações desenvolvido pelos membros do <a href="https://www.csail.mit.edu/">CSAIL</a>, do MIT, e publicado em 2001. 
Desde então, inspirou diversos outros sistemas, tornando-se sinônimo com P2P.</p>
<h5 id="identificacao_1">Identificação</h5>
<p>No Chord o problema da identificação dos dados é resolvido usando-se chaves de <strong><span class="arithmatex">\(m\)</span> bits</strong>, geradas por meio de uma função hash criptográfica a partir de chaves que faça sentido para a aplicação, por exemplo nome, telefone, ou CPF.
Como a função hash é criptográfica, uma pequena variação na entrada implica em grande variação na saída e, para quem observa apenas a saída da função, uma sequência de chaves é indistinguível de uma sequência aleatória.</p>
<h5 id="divisao-de-carga">Divisão de carga</h5>
<p>A cada nó é atribuído um identificador único de <strong><span class="arithmatex">\(m\)</span> bits</strong>, gerado aleatoriamente. 
Como <span class="arithmatex">\(m\)</span> normalmente é grande, com mais de uma centena de bits, a probabilidade de dois nós terem o mesmo identificar é desprezível.
Além disso, os nós se organizam em uma rede sobreposta estruturada na forma de um <strong>anel lógico</strong>, em que os nós aparecem ordenadamente de acordo com seus identificadores.
A figura a seguir mostra um anel em cujo os nós tem identificadores de 8 bits (0 a 255), com cinco nós.<sup id="fnref:chord_dist"><a class="footnote-ref" href="#fn:chord_dist">4</a></sup>
Assumamos inicialmente que os nós só estão cientes dos seus vizinhos imediatos no anel.</p>
<p><img alt="Anel Chord" src="../drawings/chord.drawio-0.svg" /></p>
<p>Cada chave é associada a um nó, responsável por atender requisições de criação, consulta, modificação e remoção dos dados relacionados àquela chave.
A pseudo aleatoriedade na geração da chave e a aleatoriedade na geração dos identificadores de nós faz com que a distribuição de carga entre os nós seja uniforme.
O dado com chave <span class="arithmatex">\(k\)</span> é responsabilidade do nó com menor identificador <span class="arithmatex">\(i \geq k\)</span>, aka, <strong>sucessor de <span class="arithmatex">\(k\)</span></strong> (<span class="arithmatex">\(i = suc(k)\)</span>), no anel.
Na figura a seguir, é apresentado junto a cada nó as chaves pelas quais o nó é responsável.</p>
<p><img alt="Anel com Chaves no Chord" src="../drawings/chord.drawio-1.svg" /></p>
<h5 id="roteamento_1">Roteamento</h5>
<p>Suponha que um cliente solicite ao Chord do exemplo anterior que armazene o valor <span class="arithmatex">\(v\)</span> associado à chave <span class="arithmatex">\(k\)</span>.
A solicitação é feita pelo contato a um dos nós no sistema, que pode ou não ser o responsável por <span class="arithmatex">\(k\)</span>.
Caso seja o responsável, a solicitação é executada localmente e uma resposta devolvida ao cliente.
Caso contrário, a requisição deve repassada ou <strong>roteada</strong> para o nó correto.</p>
<p>Na rede estruturada definida até agora, uma opção óbvia é repassar a requisição para um dos vizinhos e assim sucessivamente até que alcance o nó correto. 
Esta solução, correta, tem custo da ordem do número de nós no sistema, <span class="arithmatex">\(O(n)\)</span>.
Em uma instância com milhares de nós, <span class="arithmatex">\(O(n)\)</span> é um custo muito alto, ainda mais se considerarmos que cada salto na rede sobreposta potencialmente cruza toda a Internet, uma vez que, reforçando, a proximidade na rede sobreposta não implica em proximidade na rede física abaixo.
Observe que o custo em termos de espaço para se implementar esta solução é <span class="arithmatex">\(O(1)\)</span> para cada nó do sistema.
Em outras palavras, cada nó mantem uma <strong>tabela de rotas</strong> com uma ou duas entradas, apontando para seus vizinhos.</p>
<p>Com uma rede com milhares de nós, uma solução <span class="arithmatex">\(O(n)\)</span> saltos, onde cada pode levar <strong>ao outro lado do planeta</strong>, operações teriam uma latência muito alta.
Para amenizar o custo, Chord propõe a criação de uma tabela de rotas, também conhecida como <em>finger-table</em>, que aponta para nós no anel com distâncias que se dobram a cada entrada.</p>
<p><img alt="Anel com Chaves no Chord" src="../drawings/chord.drawio-2.svg" /></p>
<p>A <em>finger-table</em> é construída da seguinte forma, onde <span class="arithmatex">\(m\)</span> é a quantidade de bits usados para identificar nós no sistema:</p>
<ul>
<li>seja <span class="arithmatex">\(F_p\)</span> a <em>finger-table</em> do processo <span class="arithmatex">\(p\)</span>;</li>
<li>seja <span class="arithmatex">\(F_p[i]\)</span> a <span class="arithmatex">\(i\)</span>-ésima da tabela; e,</li>
<li><span class="arithmatex">\(F_p[i] = suc(p+2^{i-1})\)</span>.</li>
</ul>
<p>Observe que nesta tabela, a <span class="arithmatex">\(i\)</span>-ésima entrada aponta para o processo que no que sucede <span class="arithmatex">\(p\)</span> pelo menos <span class="arithmatex">\(2^{i-1}\)</span>, e que esta distância de sucessão aumenta exponencialmente. 
Observe também que a maior distância é proporcional a metade do tamanho do anel.
Isto quer dizer que o último <em>finger</em> da tabela proporciona um salto de <span class="arithmatex">\(1/2\)</span> anel, o penúltimo <span class="arithmatex">\(1/4\)</span> do anel, o ante-penúltimo <span class="arithmatex">\(1/8\)</span>, e assim sucessivamente.
Outra forma de se ver esta tabela é como proporcionando um salto de pelo menos metade da distância restante para o nó responsável pela chave, resultando em um roteamento com custo <span class="arithmatex">\(O(log n)\)</span>.</p>
<p>Mas como este potencial é explorado? Usando-se o seguinte algoritmo de busca pela entrada correta na tabela de roteamento, do ponto de vista do processo <span class="arithmatex">\(p\)</span>:</p>
<ul>
<li>seja <span class="arithmatex">\(k\)</span> a chave para qual estamos procurando o sucessor;</li>
<li>itere pela tabela até achar a primeira entrada cujo valor, i.e., o identificador de um nó, é maior que <span class="arithmatex">\(k\)</span>;</li>
<li>se a entrada é a primeira da tabela, então encaminhe a requisição para o nó apontado, pois ele é o sucessor de <span class="arithmatex">\(k\)</span>, até onde <span class="arithmatex">\(p\)</span> consegue determinar;</li>
<li>senão, encaminhe a requisição para a entrada anterior, pois o nó referenciado está mais próximo do sucessor para determiná-lo com segurança.</li>
</ul>
<p>Considere no exemplo a seguir a busca pelo sucessor de 26, iniciada pelo nó 1.</p>
<p><img alt="" src="../images/05-04.png" /></p>
<p>Duas observações são importantes aqui. A primeira, é que as comparações para se encontrar a entrada correta, deve respeitar o anel, por exemplo, em um anel com 32 posições, por exemplo, <span class="arithmatex">\(31 &lt; 0\)</span>. No seguinte exemplo, considere por exemplo a busca que o nó 21 faz pelo sucessor de 31; qual deve ser a entrada selecionada?</p>
<p><img alt="" src="../images/05-04.png" /></p>
<p>A segunda observação é que não se pode encaminhar a requisição diretamente para o nó apontado na entrada encontrada, pois a visão de <span class="arithmatex">\(p\)</span> pode ser incompleta para partes distantes do anel.
Tente identificar exemplos no anel a seguir onde este comportamento seria errado.</p>
<p>A organização dos nós em um anel virtual e a distribuição da responsabilidade dos dados pelo particionamento do espaço das chaves de forma correspondente às faixas no anel lógico é a técnica conhecida como <strong>espalhamento consistente</strong>, do inglês, <em>consistent hashing</em>.</p>
<h5 id="churn">Churn</h5>
<p>Apesar do espalhamento consistente ser uma técnica muito útil, ela não resolve todos os problemas. Aliás, vários outros problemas precisam ser resolvidos, sendo o primeiro deles lidar com a entrada e saída de nós, principalmente por falhas de nós e comunicação.</p>
<p>Quando um novo nó entra do sistema, ele precisa seguir os seguintes passos:</p>
<ul>
<li>Escolher um novo Identificador <span class="arithmatex">\(I\)</span></li>
<li>Identificar o sucessor <span class="arithmatex">\(S\)</span> de <span class="arithmatex">\(I\)</span></li>
<li>Identificar o antecessor <span class="arithmatex">\(A\)</span> de <span class="arithmatex">\(I\)</span></li>
<li>Informar <span class="arithmatex">\(A\)</span> e <span class="arithmatex">\(S\)</span> de sua entrada, para que ajustem suas tabelas de rota.</li>
<li><span class="arithmatex">\(A\)</span> e <span class="arithmatex">\(S\)</span> propagam a informação da entrada de <span class="arithmatex">\(I\)</span> para seus vizinhos, permitindo que ajustem suas tabelas de rota.</li>
</ul>
<p>Além disto, a reorganização dos nós exige movimentação de dados, pois parte dos dados armazenados em <span class="arithmatex">\(S\)</span>, com chaves menores que <span class="arithmatex">\(I\)</span>, precisam ser copiadas para <span class="arithmatex">\(I\)</span>, o novo responsável.
As principais questões a serem respondidas durante a movimentação dos dados são</p>
<ul>
<li>como manter os dados disponíveis para inserção e consulta durante todo o processo, e</li>
<li>como minimizar o impacto da reorganização nos nós vizinhos ao novo nó</li>
</ul>
<p>Quanto à primeira questão, pode-se rotear as requisições para os dois nós responsáveis, o atual e o novo, e combinar as respostas, mantendo os dados mais recentes.
Quanto à segunda, uma opção é fazer com que cada novo nó assuma diversas posições no anel, com identificadores distintos, passando a "incomodar" múltiplos processos, mas de forma mais suave.</p>
<p>Embora se possa "facilmente" resolver os problemas da entrada de nós, os da saída são mais complexos, principalmente porquê a saída acontece geralmente bruscamente, por exemplo por falhas no sistema.
Quanto à reorganização das tabelas de rota, cada nó precisa monitorar os nós que figuram em sua tabela e, caso pareçam indisponíveis, ajustar par apontar para outro nó.
Contudo, caso a suspeita seja indevida, isto pode levar a dados serem consultados e armazenados nos nós errados.
Também com relação aos dados, há o problema de não perdê-los quando o nó responsável se torna indisponível.
O tratamento destes problemas está relacionado e é feito pelo replicação dos dados em múltiplos nós. Isto é feito no Chord, por exemplo, da seguinte forma:</p>
<ul>
<li>para cada dado, com chave <span class="arithmatex">\(k\)</span>, há <span class="arithmatex">\(r\)</span> cópias;</li>
<li>a primeira cópia é mantida no sucessor de <span class="arithmatex">\(k\)</span>;</li>
<li>a segunda cópia, no sucessor do sucessor de <span class="arithmatex">\(k\)</span>, e assim por diante;</li>
<li>cada escrita é feita na primeira cópia, respondida, e replicada para as demais cópias;</li>
<li>cada leitura é feita na cópia com menor identificador.</li>
</ul>
<p>No caso de falha de uma cópia, há <span class="arithmatex">\(r-1\)</span> cópias ainda disponíveis para responder à requisição, mantendo o sistema disponível a despeito de (<span class="arithmatex">\(r-1\)</span>) falhas, no que se chama de <strong>degradação graciosa</strong>.
Há contudo, um problema introduzido por esta abordagem. Assuma a seguinte sequência de passos, em um sistema com <span class="arithmatex">\(r=2\)</span>.</p>
<ul>
<li>escrita na cópia 1;</li>
<li>resposta ao cliente;</li>
<li>replicação para cópia 2;</li>
<li>escrita na cópia 1;</li>
<li>resposta ao cliente;</li>
<li>falha da cópia 1;</li>
<li>leitura na cópia 2.</li>
</ul>
<p>O cliente, ao ler o dado, lê uma versão antiga do mesmo, inconsistente com a visão que tinha do sistema.
De fato, este tipo de sistema é chamado de eventualmente consistente pois somente na <strong>ausência de falhas e de escritas</strong> as diversas réplicas serão consistentes umas com as outras.
Continuemos a sequência:</p>
<ul>
<li>escrita na cópia 2;</li>
<li>cópia 1 volta a funcionar;</li>
<li>leitura na cópia 1.</li>
</ul>
<p>Neste caso, a cópia "secundária" 2 tem um dado mais atual, que precisa ser repassado para a cópia 1; este movimento de convergência de dados é conhecido como anti-entropia.
Finalmente, continuemos a sequência:</p>
<ul>
<li>escrita na cópia 1, por outro cliente.</li>
</ul>
<p>Assim, ambas as cópias, 1 e 2, tem dados derivados da primeira escrita, mas feitos "concorrentemente", um <strong>conflito</strong>.
Qual dos dois é o correto neste contexto? É impossível apresentar uma estratégia genérica para resolver esta situação, mas alguns sistemas usarão uma estratégia do tipo "a última escrita vence", onde a última escrita pode ser determinada em por relógios lógicos, vetoriais, tempo, e uma pitada de "arranjo técnico" para quebrar empates.
O Dynamo, que veremos a seguir, é um destes sistemas.</p>
<div class="admonition note">
<p class="admonition-title">Espalhamento Consistente</p>
<ul>
<li>Carga uniforme entre nós.</li>
<li>Todos os nós sabem como rotear requisições</li>
<li>Número de saltos médio é conhecido.</li>
<li>O sistema se adapta a entrada e saída de nós, por falhas ou não.</li>
</ul>
</div>
<h4 id="estudo-de-caso-dynamodb">Estudo de Caso: DynamoDB</h4>
<p>DynamoDB é o marco fundamental dos bancos de dados NoSQL. 
No vídeo a seguir um de seus evangelizadores, descreve rapidamente o banco, os cenários em que deveria ser usado e diversos padrões de projeto para modelagem de dados.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/HaEPXoXVf2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Enquanto o assiste, alguns pontos devem ser ressaltados sobre o Dynamo de forma específica e os NoSQL de forma geral:     </p>
<ul>
<li>surgiram da necessidade de escalabilidade dos bancos de dados, isto é, da necessidade de lidar com milhões e milhões de entradas de dados, gerados e processados com baixa latência e alta vazão, a despeito de falhas;</li>
<li>maior escalabilidade implica em maior exposição a particionamentos da rede em que o sistema roda, que associado à necessidade de manutenção de alta disponibilidade, implica em perda de garantias de consistência (veremos o <a href="https://en.wikipedia.org/wiki/CAP_theorem">Teorema CAP</a> adiante);</li>
<li><em>Partition keys</em> são as chaves usadas para roteamento dos dados, ou seja, as chaves discutidas anteriormente neste capítulo sobre sistema P2P;</li>
<li><em>Sort keys</em> são chaves usadas dentro de cada nó para ordenar os dados na hora de gerar as SSTables (<em>String Sorted Tables</em>), e se usadas em agregados de valores, são equivalentes ao <em>GROUP BY</em> do SQL;</li>
<li><em>Lambda functions</em>  são funções para processamento de dados executadas em entradas definidas por um pipeline de processamento sem a definição explícita de sockets e portas, em um modelo conhecido como <a href="https://en.wikipedia.org/wiki/Serverless_computing">Serverless</a>.</li>
</ul>
<p>Este modelo é adequado a algumas aplicações, como o carrinho de compras da Amazon.com, aplicação para a qual o Dynamodb foi inicialmente desenvolvido.
Nesta aplicação, cada usuário tem um <strong>identificador único</strong>, recuperado no momento em que se loga ao sistema da Amazon.
Este identificador único é a <strong>chave de particionamento</strong> e os dados são o conteúdo do carrinho de compras.</p>
<p>Para lidar com falhas, o conteúdo do carrinho é replicado nos nós sucessivos ao responsável pela dupla chave valor.
O carrinho é <strong>modificado atomicamente</strong>, isto é, sobrescrito por inteiro. A replicação, associada às modificações atômicas, potencializa conflitos, que são identificados comparando-se os vetores de versão (relógios vetoriais) associados a cada valor escrito.
No caso de conflitos, as múltiplas cópias concorrentes são apresentadas ao usuário na forma de um carrinho de compras com a união dos itens nos respectivos carrinhos, de forma que o usuário possa corrigí-lo. Na pior das hipóteses, uma compra com erros será feita, e necessitará de uma atividade compensatória para o usuário, como um brinde.</p>
<p>Na prática, muitos sistemas mantém os papéis de clientes, que requisitam a execução de serviços, e servidores, que executam as requisições, mas distribuem as tarefas dos servidores entre pares para aquela função, sendo efetivamente sistemas híbridos. 
Este é o caso dos bancos de dados NOSQL, como o Dynamo, que acabamos de estudar, e também do Cassandra, que veremos a seguir.</p>
<p><img alt="CassandraDB" src="../drawings/cassandra_hibrido.drawio-0.svg" /></p>
<h4 id="estudo-de-caso-cassandra">Estudo de Caso: Cassandra</h4>
<p>Outra alternativa é fazer com que cada nó do sistema conheça todos os outros. Assim, cada requisição pode ser diretamente encaminhada ao nó responsável por tratá-la. 
O custo do roteamento, neste caso, é <span class="arithmatex">\(O(1)\)</span>, muito mais rápido que na abordagem anterior. O custo de armazenamento da <em>tabela de rotas</em> é, contudo, <span class="arithmatex">\(O(n)\)</span>, o que pode ser proibitivo em uma rede com milhares de nós, apesar de ser uma solução viável em redes menores. Este é o caso do CassandraDB, uma banco de dados distribuído baseado no Chord, que estudaremos melhor mais adiante, considerado uma DHT de salto único (<em>single-hop</em> DHT).</p>
<p>O CassandraDB foi, sem sombra de dúvida, influenciado pelo projeto do DynamoDB, o que é facilmente explicável já que um dos criadores do Dynamo foi o arquiteto do Cassandra.
Mas em vez de uma cópia, o Cassandra largamente expande a funcionalidade do Dynamo ao se inspirar no banco de dados <a href="https://en.wikipedia.org/wiki/Bigtable">BigTable</a>, do Google.
Com isso, o Cassandra se aproxima do modelo relacional, facilitando o desenvolvimento de certas aplicações, sem perder as características desejáveis das DHT.<br />
A principal característica neste sentido é o modelo híbrido chave-valor/relacional, em que os valores associados a uma chave são divididos em colunas.
A combinação chave-colunas são denominadas <strong>column-families</strong> e seu conjunto <strong>keyspace</strong>. Estas duas estruturas são equivalente às tabelas/relações e aos bancos de dados, dos bancos de dados  relacionais. </p>
<p><img alt="keyspace" src="../images/cass_keyspace.jpg" /></p>
<p>Uma diferença fundamental entre column-families e relações é que as últimas precisam de um esquema pré-definido, enquanto que as primeiras não tem um esquema. Isto quer dizer que novas colunas podem ser adicionadas dinamicamente e que nem todas precisam estar presentes para cada chave. De fato, múltiplos registros com a mesma chave, ou linhas, podem ter conjuntos de colunas diferentes.</p>
<p><img alt="Column-family" src="../images/cass_column_family.jpg" /></p>
<p>Para que o correto conjunto de colunas associado a uma chave possa ser apurado, após múltiplas escritas com a mesma chave tenham ocorrido, a cada tupla (chave,coluna,valor) é associado também um <em>timestamp</em>.<br />
<img alt="timestamps" src="../images/cass_column.jpg" />.<br />
Assim, dados uma mesma chave e coluna, o valor válido é o com o maior timestamp.
Devido a possibilidade de valores serem escritos para diferentes colunas independentemente, valores válidos e inválidos podem ter o mesmo <em>timestamp</em>.
Por exemplo, considere os seguintes dados escritos no banco:</p>
<table>
<thead>
<tr>
<th>Chave</th>
<th>Coluna<span class="arithmatex">\(\rightarrow\)</span>Valor</th>
<th>Timestamp</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>Nome<span class="arithmatex">\(\rightarrow\)</span>José, Idade<span class="arithmatex">\(\rightarrow\)</span>30</td>
<td>02:02:2020,13:45:00</td>
</tr>
<tr>
<td>3</td>
<td>Idade<span class="arithmatex">\(\rightarrow\)</span>33</td>
<td>02:02:2020,13:50:00</td>
</tr>
<tr>
<td>3</td>
<td>Telefone<span class="arithmatex">\(\rightarrow\)</span>333444554433</td>
<td>02:02:2020,13:55:00</td>
</tr>
</tbody>
</table>
<p>Uma busca pelos dados associados à chave 3 retornará o seguinte resultado:  Nome<span class="arithmatex">\(\rightarrow\)</span>José, Idade<span class="arithmatex">\(\rightarrow\)</span>33, Telefone<span class="arithmatex">\(\rightarrow\)</span>333444554433.
Para facilitar mais ainda o desenvolvimento, o Cassandra conta com uma linguagem de consulta similar ao SQL (Structured Query Language), a CQL (Cassandra Query Language).
Assim, a consulta a estes dados seria mais ou menos como <code class="highlight"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dados</span> <span class="k">WHERE</span> <span class="k">key</span> <span class="o">==</span> <span class="mi">3</span></code>.<sup id="fnref:cql_sintax"><a class="footnote-ref" href="#fn:cql_sintax">5</a></sup></p>
<p>Há muitos recursos <em>online</em>  para se aprender mais se aprender mais sobre como usar o Cassandra, por exemplo, <a href="http://wiki.apache.org/cassandra/GettingStarted">aqui</a>.
Há também diversos projetos de código livre que o usam e podem ser estudados, por exemplo, o clone de Twiter <a href="https://github.com/twissandra/twissandra">Twissandra</a>.
Mas embora o uso de sistemas gerenciadores de bancos de dados em sistemas distribuídos seja interessante, aqui nos focaremos em alguns dos aspectos de como estes SGBD são construídos.</p>
<div class="admonition note">
<p class="admonition-title">Detalhes de Implementação</p>
<p>A seção de <a href="../tech/#estruturas-de-dados-para-sd">tecnologias</a> descreve várias estruturas de dados recorrentemente usadas em implementação de bancos de dados como o Cassandra.</p>
</div>
<h4 id="outros-exemplos">Outros exemplos</h4>
<p>P2P é terreno fértil e poderíamos passar muito tempo apenas enumerando exemplos interessantes, mas nos limitaremos aqui a dois dos mais atuais.
O primeiro é o sistema de compartilhamento de arquivos já mencionado na <a href="../intro/index.html">introdução</a>, BitTorrent.</p>
<p><img alt="Bittorrent" src="../images/bittorrent.png" /></p>
<p>O que há de mais interessante neste exemplo o fato de haverem diversas implementações dos clientes, e.g., <span class="arithmatex">\(\mu\)</span>Torrent, Azureus, Transmission, Vuze, qTorrent, implemenados em diversas linguagens e para diversas plataformas, todos interoperáveis.
Isso é um atestado do que uma <a href="http://bittorrent.org/beps/bep_0003.html">especificação</a> bem feita e aberta pode alcançar.</p>
<p>O segundo é o sistema que suporta a criptomoeda BitCoin, em que milhares de nós armazenam coletivamente o histórico de transações de trocas de dono das moedas. 
Mas em vez de expandir aqui este assunto, deferiremos esta discussão para a seção <a href="../tech/#blockchain">BlockChain</a>.
Apenas para abrir o apetite, </p>
<h3 id="hibridos">Híbridos</h3>
<p>Embora cliente/servidor e P2P sejam arquiteturas clássicas, boa parte dos sistemas que distribuídos podem ser na verdade considerados híbridos.
Considere um sistema de email, por exemplo. 
Embora clientes usem as funcionalidades dos servidores de email para enviar e receber mensagens, os servidores conversam uns com os outros para implementar a tarefa de encaminhar as mensagens. 
Neste sentido, o sistema é um híbrido P2P e cliente/servidor.</p>
<p>Outros exemplos abundam.</p>
<ul>
<li>Bancos de dados, e.g., DynamoDB, <a href="https://www.atlassian.com/blog/archives/do-you-know-cassandra">CassandraDB</a>, Redis,...</li>
<li>Jogos multiplayer (pense no <a href="http://pages.cs.wisc.edu/~vshree/cs740/Voronoi.pdf">particionamento dos mapas</a>)</li>
<li>Compartilhamento de arquivos: Bittorrent</li>
</ul>
<p>Voltemos ao exemplo do Bittorrent; observe na figura adiante os diversos passos necessários à recuperação do arquivo de interesse neste sistema.
Diversos passos seguem a arquitetura cliente/servidor enquanto "somente" o passo de compartilhamento de arquivos é P2P.</p>
<p><img alt="Bittorrent" src="../images/bittorrent.png" /></p>
<p>Voltando ao exemplo do sistema de informação, observe que o cliente acessa um serviço, implementado por pares de nós. 
Podemos dizer que também este é híbrido.</p>
<div class="mermaid">graph LR
  A[Cliente] --&gt;|Requisição| B{Monitor de Transações}
  B --&gt;|Resposta| A
  B --&gt;|Requisição| C[(Servidor 1)]
  B --&gt;|Requisição| D[(Servidor 2)]
  B --&gt;|Requisição| E[(Servidor 3)]

  C --&gt;|Resposta| B
  D --&gt;|Resposta| B
  E --&gt;|Resposta| B</div>
<h2 id="arquitetura-orientada-a-microsservicos">Arquitetura Orientada a Microsserviços</h2>
<p>Diversas outras arquiteturas podem e foram propostas para o desenvolvimento de Sistemas Distribuídos.
A moda da vez é a chamada arquitetura de <strong>microsserviços</strong>, na qual a divisão de tarefas entre componentes visa levar aos componentes mais simples para tal tarefa. Assim, os mesmos podem ser replicados, escalonados, desenvolvidos e mantidos independentemente.
Cada tarefa conta então com diversos componentes, organizados em camadas resolvendo um problema em específico, mas todos contribuindo para a realização de uma tarefa maior comum.</p>
<p><img alt="Microserviços" src="../images/microservice_sample.png" /></p>
<p>No dia 3 de Junho de 2020, o termo <strong>microservice</strong> resultava em 6.6 milhões de resultados no <a href="https://www.bing.com/search?q=microservice&amp;PC=U316&amp;FORM=CHROMN">Google</a>.
Isso porquê a organização de aplicações distribuídas na forma de "pequenos" processos, especializados e independentes e que colaboram para implementar um serviço maior, se tornou um padrão importante no desenvolvimento de novas aplicações.
Exatamente por isso, precisamos começar com um aviso: diversas tecnologias surgiram com grande estrondo, sendo alguns exemplos recentes Docker, Golang, Angular, e JQuery, e embora seja certo que algumas destas encontrarão seus nichos, como fizeram antes delas Cobol, C, e SQL, outras desaparecerão da face da indústria; afinal, quem sabe o que é Delphi e quem ainda usa JQuery? <a href="http://www.zdnet.com/article/microservices-101-the-good-the-bad-and-the-ugly/">Os micro-serviços não são uma panacéia</a></p>
<p>Este fenômeno é capturado pelas várias fases do <em>hype-cycle</em> da Gartner.<sup id="fnref:hype_gartner"><a class="footnote-ref" href="#fn:hype_gartner">6</a></sup></p>
<p><a href="https://www.gartner.com/en/research/methodologies/gartner-hype-cycle"><img alt="Hype Cycle" src="../images/gartner-hype-cycle-overview.png" /></a></p>
<p>A Arquitetura Orientada a microsserviços, tendo atingido o pico das expectativas infladas<sup id="fnref:gartner_inflated"><a class="footnote-ref" href="#fn:gartner_inflated">7</a></sup> em 2017, está deslizando na <a href="https://www.gartner.com/en/documents/3955980/hype-cycle-for-application-architecture-and-development-">Trough of Desillusionment</a><sup id="fnref2:gartner_inflated"><a class="footnote-ref" href="#fn:gartner_inflated">7</a></sup> em 2019.
Isto é, este modelo de desenvolvimento não é mais propagandeado como uma bala de prata para todas as aplicações distribuídas.
Ainda assim, é um importante modelo. Mas afinal, o que é a arquitetura de microsserviços?
Em vez de explicar diretamente o que são, pode ser mais fácil pensar primeiro termos do que não são, em termos de sistemas monolíticos. <br />
<a href="http://www.imdb.com/title/tt0062622/"><img alt="2001 Space Odyssey" src="../images/monolith_2001.jpg" /></a>   </p>
<p>Uma extrapolação que pode ser feita aqui, reforçando a observação que problemas (e soluções) de sistemas distribuídos são refletidos em nível de processamento paralelo e concorrente, é que a uma arquitetura SEDA lembra em muito a arquitetura de <a href="http://muratbuffalo.blogspot.com.br/2011/02/seda-architecture-for-well-conditioned.html">micro-serviços</a>.</p>
<p>Observe que à direita no exemplo de microsserviços, se vê um conector (ou componente) denominado <strong><em>event bus</em></strong>.
A ideia é que componentes publiquem mensagens no barramento, os <strong><em>publishers</em></strong>, e que componentes interessados em mensagens de algum tópico, os <strong><em>subscribers</em></strong> se subscrevam. 
O barramento então serve de canal de comunicação, entregando as mensagens publicadas a quem tiver interesse, implementando assim uma arquitetura <strong><em>publish/subscribe</em></strong>.</p>
<h3 id="monolitos">Monolitos</h3>
<p>Muitas aplicações seguem o modelo de 3 camadas em que em um dos extremos tem-se a interface com os usuários, materializada normalmente por um navegador, no outro tem-se um SGBD onde são armazenados os dados da aplicação, e, no meio, a lógica do negócio.
A camada central, implementada por um único processo, que alimenta a interface com o usuário, manipula o modelo de dados, e onde reside a lógica do negócio, é um <strong>monolito</strong>.</p>
<p><a href="http://nodexperts.com/blog/microservice-vs-monolithic/"><img alt="Monolitos" src="../images/monolith_arc.png" /></a></p>
<p>Monolitos seguem um modelo simples e largamente utilizado de desenvolvimento em que vários contribuidores implementam partes distintas da lógica, que são compiladas em conjunto e colocadas em produção de forma atômica:   </p>
<ol>
<li>Desenvolva</li>
<li>Teste</li>
<li>Implante</li>
<li>volte ao passo 1</li>
</ol>
<p>Simples não quer dizer necessariamente eficiente; no caso de atualizações de uma parte do sistema, <strong>todo o monolito precisa ser trocado</strong>, incorrendo em, com raras exceções, <strong>indisponibilidade total</strong> do sistema, incluindo as partes não modificadas.
Esta dificuldade tende a limitar as <strong>janelas de atualização</strong> do sistema, o que aumenta no número de mudanças que ocorrem a cada atualização, o que <strong>aumenta o risco de regressões</strong> e portanto requer mais testes, o que aumenta o intervalo entre janelas de atualização. 
Além disso, nos caso de bugs, é mais difícil encontrar o problema, uma vez que fica <strong>impossível aos desenvolvedores conhecer todo o sistema</strong>.
Isso apenas exacerba o problema, o que limita mais ainda as atualizações, gerando um <strong>ciclo vicioso</strong> que mantem desenvolvedores acordados nas madrugadas de sexta para sábado quando é dia de <em>deploy</em>.</p>
<p>Sistemas monolíticos também podem ser problemáticos quanto à escalabilidade, pois quando a capacidade do sistema é atingida, ou todo o sistema é movido para um <em>host</em> de maior capacidade ou todo o sistema deve ser  replicado.
Na primeira abordagem, o custo geralmente é um empecilho, pois preços de hardware crescem exponencialmente com <em>scale up</em>. 
Além disso, um servidor, por mais parrudo que seja, é um Ponto Único de Falha (ou SPOF, do inglês <em>single point of failure</em>).
Quanto à segunda abordagem, ela traz complexidades na coordenação das réplicas e ineficiências ao replicar inclusive as partes subutilizadas.
Ambas as abordagens também esbarram na escalabilidade do banco de dados que lhes serve de <em>backend</em>.
Para contornar ou pelo menos minimizar estes problemas, pode-se fragmentar o serviço e o banco de dados, o que facilita tanto a escalabilidade vertical quanto horizontal de cada módulo, que é menor e mais simples de coordenar, e divide a carga nos bancos de dados; mas isso é a troca do serviço monolítico por microsserviços.</p>
<h3 id="microsservicos">Microsserviços</h3>
<p>De acordo com <a href="https://martinfowler.com/articles/microservices.html">Lewis &amp; Fowler</a></p>
<blockquote>
<p>The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p>
</blockquote>
<p>Em outras palavras, com os microsserviços, quebra-se o monolito em diferentes processos, "<em>small autonomous services that work together, modelled around a business domain</em>", cada um gerenciando os dados relevantes para aquela parte do sistema e, possivelmente, sua própria interação com o usuário.
Com o uso de microsserviços, se dá mais um passo em direção à máxima escalabilidade do sistema.
<a href="https://thenewstack.io/from-monolith-to-microservices/"><img alt="Escala de Microsserviços" src="../images/microservices_scale.png" /></a></p>
<p>Este modelo tem implicações diretas no desenvolvimento: cada processo é desenvolvido por um time diferente, que mantem controle sobre desenvolvimento, teste, e manutenção em produção, o que é factível já que cada serviço é simples e focado em um problema pequeno e ninguém tem que entender em detalhes o funcionamento de todo o sistema.</p>
<p>Além disso, quando um serviço precisa ser atualizado, se bem projetados, todos os demais podem continuar operantes e é possível até que múltiplas versões do mesmo serviço sejam executadas concorrentemente, possibilitando atualizações sem janelas de manutenção.  </p>
<p>Quanto à escalabilidade, esta é feita independentemente também; no exemplo na imagem seguinte, é provável que o serviço de acesso ao catálogo seja mais utilizado que os demais e portanto merecedor de mais recursos e mais cópias.</p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/microservice-application-design"><img alt="" src="../images/microservice_sample.png" /></a></p>
<p>Como se percebe facilmente, o uso de microsserviços pode ser relacionado às técnicas de processamento paralelo: trate dados diferentes em blocos diferentes (paralelismo de dados ou replicação) e trate funções diferentes em blocos diferentes (paralelismo de tarefas ou <em>sharding</em>).
Como na computação paralela, na "componentização" é importante considerar os requisitos das diferentes tarefas em termos de CPU, E/S, e memória, para que possam escalar independentemente e não gerar gargalos desnecessários.</p>
<h3 id="do-monolito-aos-microsservicos">Do Monolito aos Microsserviços</h3>
<p>Com tantas vantagens, surge a dúvida se todos os sistemas deveriam ser desenvolvidos usando-se a arquitetura de microsserviços.
A resposta é <strong>não</strong>, pois como colocado no início desta seção, <strong>não existem balas de prata</strong> e se um sistema monolítico está funcionando para você e não há perspectiva de problemas acometerem (a demanda no sistema não está aumentando, a lógica do sistema é muito simples, indisponibilidade não te traz prejuízo, você não pode arcar com a refatoração), então mantenha seu sistema como está.</p>
<p>Caso haja a necessidade de evolução e o modelo de microsserviços pareça adequado, existem recomendações de como a migração pode ser feita.
Primeiro, é preciso aceitar que o desenvolvimento de microsserviços afeta a organização do time de desenvolvimento e que a organização provavelmente refletirá a arquitetura.
O desenvolvimento, manutenção e operação de microsserviços acontece em times pequenos, de 1 a 8 pessoas ("pizza team"), dependendo da complexidade do serviço; se houver a necessidade de mais pessoas no time, o escopo do microsserviço provavelmente está grande demais; cada componente resolve um problema, bem.</p>
<p>Segundo, a mudança não deverá acontecer atomicamente. 
Uma boa estratégia é identificar uma parte do sistema que funcionaria bem como microsserviço, desenvolvê-la e modificar o monolito para usar o microsserviço.
O aprendizado então é usado para encontrar novo candidato e o procedimento é iterado até que o monolito seja apenas uma casca e possa também ser removido.
Mais fácil dito que feito, há muita documentação orientando o processo.</p>
<div class="admonition tip">
<p class="admonition-title">Para saber mais</p>
<p>Como esta arquitetura não faz parte ainda do nosso currículo, não nos aprofundaremos nela aqui.
Felizmente há muito material na Web sobre este modelo, sendo a lista a seguir uma ínfima fração.</p>
<p>Para uma explicação geral do que são, assista a Martin Fowler no vídeo seguinte, assista<br />
<iframe width="560" height="315" src="https://www.youtube.com/embed/wgdBVIX9ifA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> <br />
ou consulte os vários artigos no seu <a href="https://martinfowler.com/articles/microservices.html">sítio</a>.</p>
<p>Para entender os princípios por trás do uso da arquitetura,<br />
<iframe width="560" height="315" src="https://www.youtube.com/embed/PFQnNFe27kU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<p>Para um exemplo importante do uso de microsserviços, considere a Netflix, que usa microsserviços em larga escala em seus serviços. Quão larga? "...over five hundred services... we don't know how many..." Apesar de tal uso, ou justamente por causa dele, seus serviços mantém uma "...availability of 9.995...", ou seja, ficam indisponíveis por <strong>menos de 16 segundos por ano</strong>. <br />
<iframe width="560" height="315" src="https://www.youtube.com/embed/57UK46qfBLY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>   </p>
</div>
<p>Com respeito a estar preparado para falhas, afinal "... it is not if failures will happen... ... it is when it happens...", a empresa usa uma abordagem de injeção de falhas em serviços em produção.
    Os diferentes tiposde falhas são injetados por um "<strong>exército de macacos do caos</strong>"<br />
    <iframe width="560" height="315" src="https://www.youtube.com/embed/CZ3wIuvmHeM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> <br />
    Para uma visão prática da implementação de microsserviços usando AWS, veja
    <iframe width="560" height="315" src="https://www.youtube.com/embed/Ijs55IA8DIk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2 id="outras-arquiteturas">Outras arquiteturas</h2>
<p><em>Publish/subscribe</em> é uma das manifestações os <strong><em>message oriented middleware</em></strong>, ou MOM. 
Uma outra manifestação são as <strong>filas de mensagens</strong>, que permitem que componentes enviem mensagens para caixas postais uns dos outros.
Dependendo da implementação e do MOM usado, componentes não precisam sequer se identificar ou mesmo estar ativos ao mesmo tempo para que a troca de mensagens aconteça, novamente levando a sistemas mais ou menos acoplados.
No capítulo seguinte, usaremos um estudo de caso para no aprofundarmos em arquiteturas orientadas a mensagens, pois neste caso, a arquitetura se confunde com os conectores do nosso sistema distribuído.</p>
<details class="bug"><summary>TODO</summary><ul>
<li>SOA - Foco no uso de outras formas de comunicação para chegar em outras arquiteturas.</li>
<li>MOM - Foco na arquitetura pois o uso será visto no próximo capítulo.s<ul>
<li>Publish/Subscribe </li>
<li>Message Queues</li>
</ul>
</li>
<li>Event Sourcing    <ul>
<li><a href="https://www.confluent.io/blog/event-sourcing-cqrs-stream-processing-apache-kafka-whats-connection/">Stream Processing/Event sourcing</a></li>
<li><a href="https://www.confluent.io/blog/making-sense-of-stream-processing/">Stream Processing/Event Sourcing</a></li>
<li><a href="https://youtu.be/06iRM1Ghr1k">Kafka Overview</a></li>
</ul>
</li>
</ul>
</details>
<h2 id="referencias">Referências</h2>
<ul>
<li><a href="https://www.cs.cmu.edu/~dga/15-744/S07/lectures/16-dht.pdf">https://www.cs.cmu.edu/~dga/15-744/S07/lectures/16-dht.pdf</a></li>
<li><a href="https://keetmalin.wixsite.com/keetmalin/single-post/2017/09/27/Distributed-System-Architectures-and-Architectural-Styles">Distributed System Architectures and Architectural Styles</a>.</li>
<li>Para aprender um pouco sobre como funcionam as redes de um <em>datacenter</em>, definidas por software, assista ao seguinte vídeo, que fala sobre a infra-estrutura do Facebook. <br />
<br />
<iframe width="560" height="315" src="https://www.youtube.com/embed/mLEawo6OzFM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:shrek">
<p>Se você não pegou a referência, volte <del>uma casa</del><sup id="fnref:tabuleiro"><a class="footnote-ref" href="#fn:tabuleiro">2</a></sup> um capítulo.&#160;<a class="footnote-backref" href="#fnref:shrek" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:tabuleiro">
<p>Se você não pegou esta referência, não teve infância.&#160;<a class="footnote-backref" href="#fnref:tabuleiro" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:icpc_hyper">
<p>Neste <a href="https://icpcarchive.ecs.baylor.edu/external/22/2271.pdf">problema</a> do ICPC, um esquema de nomeação dos nós de um hypercube é apresentado; usando este esquema, derive um algoritmo de roteamento em que a distância percorrida por qualquer mensagem seja sempre igual ao número de dimensões do cubo.&#160;<a class="footnote-backref" href="#fnref:icpc_hyper" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:chord_dist">
<p>Observe que as distâncias entre os nós no anel foram desenhadas de forma proporcional à diferença numérica entre os identificadores.&#160;<a class="footnote-backref" href="#fnref:chord_dist" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:cql_sintax">
<p>Este exemplo é meramente ilustrativo e não segue estritamente a sintaxe do CQL.&#160;<a class="footnote-backref" href="#fnref:cql_sintax" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:hype_gartner">
<p>"The hype cycle is a branded graphical presentation developed and used by the American research, advisory and information technology firm Gartner, for representing the maturity, adoption and social application of specific technologies."&#160;<a class="footnote-backref" href="#fnref:hype_gartner" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:gartner_inflated">
<ul>
<li>Peak of Inflated - Expectations  Early publicity produces a number of success stories—often accompanied by scores of failures. Some companies take action; most don't.</li>
<li>Technology Trigger -- A potential technology breakthrough kicks things off. Early proof-of-concept stories and media interest trigger significant publicity. Often no usable products exist and commercial viability is unproven.</li>
<li>Slope of Enlightenment -- More instances of how the technology can benefit the enterprise start to crystallize and become more widely understood. Second- and third-generation products appear from technology providers. More enterprises fund pilots; conservative companies remain cautious.</li>
<li>Plateau of Productivity -- Mainstream adoption starts to take off. Criteria for assessing provider viability are more clearly defined. The technology's broad market applicability and relevance are clearly paying off.</li>
<li>Trough of Disillusionment - Interest wanes as experiments and implementations fail to deliver. Producers of the technology shake out or fail. Investment continues only if the surviving providers improve their products to the satisfaction of early adopters.</li>
</ul>
<p><a class="footnote-backref" href="#fnref:gartner_inflated" title="Jump back to footnote 7 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:gartner_inflated" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
</ol>
</div>

  <!-- Last update of source file -->


              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../basics/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Anterior
                </span>
                Fundamentos
              </div>
            </div>
          </a>
        
        
          <a href="../comm/" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Próximo
                </span>
                Comunicação
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.18f0862e.min.js"></script>
      <script src="../assets/javascripts/bundle.994580cf.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copiar para \u00e1rea de transfer\u00eancia", "clipboard.copied": "Copiado para \u00e1rea de transfer\u00eancia", "search.config.lang": "pt", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Buscar", "search.result.placeholder": "Digite para iniciar a busca", "search.result.none": "Nenhum resultado encontrado", "search.result.one": "1 resultado encontrado", "search.result.other": "# resultados encontrados", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: [],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.9c0e82ba.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../javascripts/mathjaxhelper.js"></script>
      
    
  </body>
</html>