<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Introdução - Sistemas Distribuídos</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Introdu\u00e7\u00e3o";
    var mkdocs_page_input_path = "intro/index.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Sistemas Distribuídos</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Prólogo</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Introdução</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#o-que">O quê?</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#por-que">Por quê?</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#como">Como?</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#middleware">Middleware</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#middleware_1">Middleware</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transparencias">Transparências</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transparencia-de-acesso">Transparência de Acesso</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#ieee-fp">IEEE FP</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#transparencia-de-acesso_1">Transparência de acesso</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transparencia-de-localizacao">Transparência de Localização</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#escondendo-a-latencia">Escondendo a Latência</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#escondendo-a-latencia_1">Escondendo a latência</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transparencia-de-relocacao">Transparência de Relocação</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#transparencia-localizacao-e-relocacao">Transparência Localização e Relocação</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transparencia-de-migracao">Transparência de Migração</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#transparencia-de-migracao_1">Transparência de Migração</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transparencia-de-replicacao">Transparência de Replicação</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#maquina-de-estados">Máquina de Estados</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#replicacao-x-inconsistencias">Replicação x Inconsistências</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#transparencia-de-concorrencia">Transparência de Concorrência</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#multi-tenancy">Multi-tenancy</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#transparencia-concorrencia">Transparência Concorrência</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#desafios-para-se-obter-transparencia">Desafios para se obter transparência</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#armadilhas-da-rede">Armadilhas da rede</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#escalabilidade">Escalabilidade</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Sistemas Distribuídos</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Introdução</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="introducao">Introdução</h1>
<p>As áreas ligadas ao desenvolvimentos de sistemas computacionais, como Ciência e Engenharia de Computação e Sistemas de Informação, estão extremamente em voga e tem atraído mais e mais profissionais, mais ou menos qualificados, tornando este <strong>mercado cada vez mais competitivo</strong>.</p>
<p>Ter conhecimentos específicos da subárea de desenvolvimento de sistemas distribuídos e pode ser uma excelente vantagem e forma de se destacar de seus colegas e competidores.
"Como assim?", você pergunta, já que nunca ouviu falar em sistemas distribuídos até ter que se matricular nesta disciplina.
Bem, o desenvolvimento da teoria da computação distribuída, na forma do estudo de algoritmos e técnicas de implementação, e sua colocação em prática, na forma do desenvolvimento de sistemas distribuídos, não é tão "quente" como outras áreas, por exemplo inteligência artificial e ciência de dados.
Mas acontece que sem a computação distribuída, nenhum desenvolvimento sério destas outras áreas, sedentas por desempenho, escalaria para problemas reais. Veja por exemplo a seguinte descrição dos <em>skills</em> necessários para atuar como <a href="https://www.quora.com/What-skills-are-expected-from-a-data-engineer-not-a-data-scientist">cientista de dados</a> ou como engenheiro no <a href="https://www.facebook.com/facebookcareers/videos/1747855735501113/">Facebook</a>.</p>
<p>Se estiver convencido de que esta é uma área importante, ótimo! 
 Neste curso apesentaremos uma visão geral do que são sistemas distribuídos, por quês técnicos para os desenvolvemos, e como fazê-lo, com uma forte componente prática, por meio do desenvolvimento de um projeto com (um dos) pés na realidade.
Caso contrário, bem, você não tem muita escolha, certo? Então tente aproveitar esta visão geral para praticar um pouco de <a href="https://pt.wikipedia.org/wiki/Programa%C3%A7%C3%A3o_neurolingu%C3%ADstica">programação neuro-liguística</a> e repita o seguinte mantra: heeeeeeeuuuuummmmmm amo computação distribuída.</p>
<p>Brincadeiras a parte, você desenvolverá um projeto em várias etapas que lhe permitirá exercitar os conceitos vistos aqui e que te levará a:</p>
<ul>
<li>programar processos que se comuniquem via redes de computadores;</li>
<li>conhecer arquiteturas clássicas de sistemas distribuídos (e.g, cliente/servidor, p2p e híbrida), seus usos e limitações;</li>
<li>escrever programas <em>multithreaded</em> simples e a entender como o uso de <em>multithreading</em> afeta os componentes de um sistema distribuído;</li>
<li>entender a problemática da coordenação e do controle de concorrência em sistemas distribuídos;</li>
<li>entender o uso de sistemas de nomeação em sistemas distribuídos bem como diversas formas de se implementar tais sistemas de nomeação;</li>
<li>entender os conceitos básicos de replicação e tolerância a falhas;</li>
<li>entender as implicações da dessincronização de relógios na coordenação, replicação e tolerância a falhas;</li>
<li>projetar sistemas com componentes geograficamente distantes, fracamente acoplados;</li>
<li>entender onde os diversos <em>middleware</em> podem ser usados para acoplar tais componentes;</li>
<li>conhecer várias técnicas que controle de concorrência controlar o acesso a um recurso compartilhado;</li>
</ul>
<h2 id="o-que">O quê?</h2>
<p>Mas afinal, o quê é um sistema distribuído? Talvez seja mais fácil começarmos por sistemas não distribuídos, ou como normalmente os denominamos, sistemas centralizados.
Pense na maioria das aplicações que desenvolveu no curso até agora. Elas provavelmente executam integralmente em um único processo, executando em uma única máquina.
Mesmo que use diferentes bibliotecas e <em>frameworks</em>, toda lógica de negócio, armazenamento e interface com usuário está contida em um mesmo lugar, e por isso são chamadas centralizadas.
Quando começou a programar este tipo de aplicação, o trabalho era basicamente colar blocos Lego, que se encaixavam perfeitamente, bastando importar a biblioteca correta e invocar suas funções.</p>
<p><img alt="Lego Rainbow" src="images/lego0.jpg" /></p>
<p>O cenário deve ter mudado um pouco no decorrer do curso e com o início de sua atividade profissional, quando passou a ter muito mais blocos, de muito mais tipos, para encaixar uns nos outros, aumentando consideravelmente a complexidade do desenvolvimento.
Mesmo que haja diferentes bibliotecas a serem usadas, com desenvolvedores e estilos diferentes, bem ou mal testadas, seus encaixes ainda fazem sentido.</p>
<p><img alt="Lego Hell" src="images/lego3.jpg" /></p>
<p>Infelizmente, programar sistemas distribuídos é muito mais complexo que sistemas centralizados.
Frequentemente temos peças que nunca foram pensadas para trabalharem juntas, e nos resta  usar um pouco de <em>crazy glue</em>,</p>
<p><img alt="Lego SD" src="images/lego5.jpg" /></p>
<p>persuasão,</p>
<p><img alt="Lego SD" src="images/lego4.jpg" /></p>
<p>e muito arame. 
No caso, o arame é de um tipo especial conhecido como cabo de rede, usado para estabelecer um canal de comunicação entre as diferentes partes do sistema. </p>
<p><img alt="Lego SD" src="images/cablemess.jpg" /></p>
<p>De fato, a principal característica de um sistema distribuído em relação a um não distribuído, é a separação de suas partes em vários componentes independentes (processos, sensores, atuadores), mas que se coordenam por meio de canais de comunicação para execução de alguma tarefa.
Assim, uma possível definição de Sistema Distribuído, que me agrada, é a seguinte:</p>
<div class="admonition note">
<p class="admonition-title">Sistema Distribuído</p>
<p>Coleção de sistemas computacionais (software ou hardware), independentes mas com alguma forma de comunicação, que colaboram na execução de alguma tarefa.</p>
</div>
<p>Uma definição mais cínica mas definitivamente realista é a de <a href="https://en.wikipedia.org/wiki/Leslie_Lamport">Leslie Lamport</a>, que certa vez disse:</p>
<blockquote>
<p>A distributed system is one in which the failure of a computer you didn't even know existed can render your own computer unusable.</p>
</blockquote>
<p>Mas se esta é a realidade da programação distribuída, por quê fazê-lo?</p>
<h2 id="por-que">Por quê?</h2>
<p>Todos estamos a par de que aplicações importantes nos dias de hoje são aplicações distribuídas rodando em grandes <em>data centers</em> com <a href="https://youtu.be/D77WDo881Pc">milhares de máquinas</a>.
Alguns exemplos óbvios são</p>
<ul>
<li><a href="https://www.amazon.com">Amazon.com</a>,</li>
<li><a href="https://www.facebook.com">Facebook</a>, e</li>
<li><a href="https://www.gmail.com">GMail</a>.</li>
</ul>
<p>Mas as razões que levam a este cenário são válidas para diversas outras aplicações.
De fato, praticamente qualquer sistema de informação que precise atingir um público considerável, necessitará aplicar técnicas de computação distribuída para conseguir <strong>escalar</strong>, isto é, "ser grande", seja no número de clientes que atende (computacionais ou humanos), seja em sua área de cobertura, ou na qualidade do serviço que presta, mesmo que não cheguem a estas escalas.</p>
<p>Este último ponto, sobre qualidade do serviço, tem a ver com a capacidade de um sistema se manter no ar a despeito de problemas, isto é, de ser tolerante a falhas.
Tolerância a falhas implica em redundância, em cópias, o que fatidicamente implica em <strong>distribuição</strong> e em <strong>Sistemas Distribuídos</strong>.</p>
<p>Há quem diga que <a href="https://devclass.com/2019/08/16/pivotal-cto-kubernetes-means-were-all-distributed-systems-programmers-now/">somos todos desenvolvedores de sistemas distribuídos agora</a>.
O fato é que computadores individuais tem capacidade limitada de processamento e armazenamento, mas nossa necessidade de poder computacional cresce exponencialmente.</p>
<p><img alt="Data Growth" src="images/datagrowth.jpg" /></p>
<p>Assim, precisamos crescer nosso poder computacional, mas aumentar a capacidade de um dispositivo (<strong>scale up</strong>) mesmo de forma linear tem custo exponencial.</p>
<p><img alt="Custo de melhoria" src="images/exponential.jpg" /></p>
<p>O que nos resta então é agregar o poder computacional de diversos computadores "baratos" (<strong>scale out</strong>) para satisfazer nossas necessidades.</p>
<p><img alt="Custo de melhoria" src="images/scaleupout.jpg" /></p>
<p>O remédio, contudo, é bem amargo: com muitos computadores conectados, vem a necessidade de coordená-los, de forma a agir de forma coerente, mesmo quando alguns deles falhem, e quanto mais computadores, maior é a probabilidade de que pelo menos um deles tenha uma CPU, disco, fonte, ou que quer que seja, falhando.
E estejam certos, <strong>computadores <a href="https://www.statista.com/statistics/430769/annual-failure-rates-of-servers/">falham</a> o tempo todo!</strong></p>
<p>Nós precisamos então entender este ambiente e determinar</p>
<ul>
<li>qual a probabilidade de um nó falhar;</li>
<li>como os computadores, ou melhor, como os processos se comunicam; </li>
<li>se mensagens podem ser perdidas, atrasadas, corrompidas;</li>
<li>se os relógios dos computadores são sincronizados;</li>
<li>se há agentes maliciosos que possam querer perturbar o sistema;</li>
<li>quais os padrões de acesso ao serviços, isto é, se aumentam à noite, diminuem no verão, etc.</li>
</ul>
<p>Assim, definimos <strong>modelos computacionais</strong>, que nos permitem desenvolver <strong>algoritmos adequados</strong> aos diversos problemas que enfrentamos.
Modelos clássicos englobam três variáveis:</p>
<ul>
<li>Comunicação;</li>
<li>Sincronismo; e,</li>
<li>Falhas.</li>
</ul>
<p>Definido o modelo computacional, podemos distribuir nosso sistema, isto é, dividir a computação/armazenamento em diversas máquinas, e coordenar suas ações para que sejam consistentes com a especificação, de forma a minimizar o tempo que o serviço fica fora do ar, entregando o serviço de acordo com expectativas especificadas. Para isto, precisamos entender </p>
<ul>
<li>como falhas (bugs, por exemplo) afetam a execução; </li>
<li>como evitar que a falha de algum componente possa levar o sistema a parar como um todo; e</li>
<li>garantir que clientes em qualquer lugar do mundo tenham a mesma facilidade em acessar o serviço.</li>
</ul>
<p>Vejamos algumas exemplos de tarefas executadas por sistemas distribuídos, que você usa hoje.</p>
<ul>
<li>Entregue este email para fulano@knowhere.uni.</li>
<li>Envie o item X para este endereço, após cobrança de Y dinheiros da conta Z.</li>
<li>Em um ambiente de simulação de batalhas em 3D, simule o disparo de um projétil nesta direção e sentido, com velocidade v, enquanto movimenta o avatar A para a esquerda.</li>
<li>Autorize a transferência de X dinheiros da conta C para a conta C'.</li>
<li>Movimente o braço mecânico que está segurando um bisturi, 3cm à direita, então abaixe-o 3mm, e movimente-o 4cm para a esquerda</li>
<li>Inclua o comentário ``LOL!!!'' na lista de comentários do item XYZ, com marca de tempo T</li>
<li>Leia o valor do sensor de temperatura S e, caso seu valor supere V, emita alarme luminoso vermelho intermitente e alarme sonoro</li>
</ul>
<p>Um sistema distribuído implica em algum tipo de colaboração entre componentes, para permitir que recursos de um sejam usados por outro. 
Por exemplo, </p>
<ul>
<li>capacidade de armazenamento, </li>
<li>de processamento, </li>
<li>conexão física com uma impressora, ou</li>
<li>localização geográfica.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Por quê distribuir?</p>
<p>As principais razões para se desenvolver sistemas distribuídos são duas, ambas resultantes da <strong>agregação</strong> (correta) do poder computacional de múltiplas máquinas:</p>
<ul>
<li>escalabilidade e</li>
<li>tolerância a falhas.</li>
</ul>
</div>
<h2 id="como">Como?</h2>
<p>Apenas para reforçar, então, distribuir é</p>
<ul>
<li>dividir a computação/armazenamento em diversos componentes</li>
<li>possivelmente geograficamente distribuídos</li>
<li>coordenar suas ações para que resolvam a tarefa em questão de forma correta.</li>
</ul>
<p>Com a distribuição objetiva-se</p>
<ul>
<li>usar recursos disponíveis nos hosts onde os componentes são executados</li>
<li>e usar de redundância para garantir que o serviço sofra degradação graciosa em caso de falhas.</li>
</ul>
<p>Para colaborar, as as diversas partes do sistema distribuído devem se comunicar.
Isto pode ser feito de diversas formas e em diversos níveis de abstração. Por exemplo:</p>
<ul>
<li>troca de mensagens,</li>
<li>streams de dados,</li>
<li>invocação remota de procedimentos</li>
<li>...</li>
</ul>
<p>Implementar estas abstrações, para então desenvolver os sistemas distribuídos é complicado por quê os sistemas precisam ser coordenados em mínimos detalhes, a despeito das seguintes características:</p>
<ul>
<li>Falhas independentes</li>
<li>Relógios dessincronizados</li>
<li>Linguagens de desenvolvimento diferentes</li>
<li>Sistemas operacionais diferentes</li>
<li>Arquiteturas diferentes</li>
<li>Desenvolvedores diferentes</li>
</ul>
<p>Quero dizer, a complexidade de se implementar estas abstrações já é grande por si só. Se formos reinventar a roda a cada novo sistema, não faremos muitos avanços.
Mas, como vocês sabem, sistemas computacionais são como ogros (muito feios, às vezes), que por sua vez, são como cebolas (cheias de camadas), que nos fazem chorar quando precisamos descascá-las.</p>
<p><img alt="" src="https://media.giphy.com/media/4RsEUfHym7tuw/200.gif" /></p>
<p>Felizmente, para cada problema que tenha que resolver, há uma boa probabilidade de que alguém já tenha atacado o problema e disponibilizado uma solução, de forma comercial ou não.
Com sistemas distribuídos, não é diferente, e no caso da comunicação entre componentes distribuídos, a solução normalmente é usar um <em>middleware</em>.</p>
<hr />
<h5 id="middleware">Middleware</h5>
<p>O <em>middleware</em>  é a camada <em>ware</em> que fica no <em>middle</em>, entre, o <em>software</em> e o <em>hardware</em>. 
Software, no caso, é a aplicação distribuída, e hardware é a <strong>abstração</strong> do <em>host</em>  em que executam os componentes, provida pelo sistema operacional.
Uso aqui o termo <strong>abstração</strong> porquê o sistema operacional pode encapsular o hardware, mas também pode encapsular outra abstração hardware, por exemplo, um máquina virtual.</p>
<hr />
<h5 id="middleware_1">Middleware</h5>
<p><img alt="Middleware" src="images/01-01.png" /></p>
<blockquote>
<p>The software layer that lies between the operating system and applications on each side of a distributed computing system in a network.</p>
</blockquote>
<hr />
<p>Segundo, <a href="https://web.archive.org/web/20050507151935/http://middleware.objectweb.org/">Sacha Krakowiak</a>, as principais funções do middleware são:</p>
<ul>
<li>esconder a distribuição e o fato de que um aplicação é geralmente composta por múltiplas partes, executando em localizações geograficamente distintas,</li>
<li>esconder a heterogeneidade dos vários componentes de hardware, sistemas operacionais e protocolos de comunicação</li>
<li>prover interfaces uniformes, de alto nível e padronizadas para os desenvolvedores de aplicação e integradores, de forma que aplicações possam ser facilmente compostas, reusadas, portadas e feitas interoperáveis.</li>
</ul>
<p>Assim, os middleware facilitam a conexão entre nós e permitem o uso de protocolos mais abstratos que "mandar um monte de bytes" para lá e para cá, escondendo a complexidade da coordenação de sistemas independentes.
Desenvolver sistemas distribuídos sem usar um middleware é como desenvolver um aplicativo qualquer, sem usar bibliotecas: possível, mas complicado, e estará certamente reinventando a roda. Isto é, você praticamente tem que refazer o middleware antes de desenvolver o sistema em si.</p>
<p>Idealmente, com o middleware se obteria transparência total do fato da aplicação estar distribuída, levando o sistema, uma coleção de sistemas computacionais (software ou hardware) independentes, a se apresentar para o usuário como <strong>um sistema único</strong>. 
Pense no browser e na WWW: quanto você sabe sobre as páginas estarem particionadas em milhões de servidores?</p>
<p>Podemos quebrar esta "transparência total" em várias transparências mais simples.
Vejamos cada uma destas separadamente.</p>
<hr />
<h5 id="transparencias">Transparências</h5>
<ul>
<li>Acesso</li>
<li>Localização</li>
<li>Relocação</li>
<li>Migração</li>
<li>Replicação</li>
<li>Falha</li>
</ul>
<hr />
<h3 id="transparencia-de-acesso">Transparência de Acesso</h3>
<p>A transparência de acesso diz respeito à representação de dados e mecanismos de invocação (arquitetura, formatos, linguagens...).
Cada computador tem um arquitetura e uma forma de representar, por exemplo, números, e se dois componentes de um SD executam em máquinas com arquiteturas diferentes, como trocam números em ponto flutuante?</p>
<hr />
<h5 id="ieee-fp">IEEE FP</h5>
<p><img alt="IEEE Floating Point" src="images/float_point.jpg" /></p>
<ul>
<li>Half Precision (16 bit): 1 sign bit, 5 bit exponent, and 10 bit mantissa</li>
<li>Single Precision (32 bit): 1 sign bit, 8 bit exponent, and 23 bit mantissa</li>
<li>Double Precision (64 bit): 1 sign bit, 11 bit exponent, and 52 bit mantissa</li>
<li>Quadruple Precision (128 bit): 1 sign bit, 15 bit exponent, and 112 bit mantissa</li>
</ul>
<p><a href="https://www.tutorialspoint.com/fixed-point-and-floating-point-number-representations">Fonte</a></p>
<hr />
<p>A mesma questão é válida para representações de strings e classes, e diferenças de sistemas operacionais e linguagens.
Assim, para se tentar obter transaparência de acesso, é importante que se use padrões implementados em múltiplas arquiteturas.</p>
<hr />
<h5 id="transparencia-de-acesso_1">Transparência de acesso</h5>
<p>Usar padrões abertos e interfaces bem definidas.
* Sistemas bem comportados e previsíveis (RPC/ASN.1)
* Que interajam bem com outros via interfaces bem definidas (REST)
* Suportem aplicações diferentes do mesmo jeito (API)</p>
<hr />
<h3 id="transparencia-de-localizacao">Transparência de Localização</h3>
<p>A transparência de localização diz respeito a onde está o objeto: pouco importa ao usuário, se o serviço está dentro da mesma máquina em que acessa o serviço, se na sala do lado, ou na nuvem, do outro lado do globo, desde que o serviço seja provido de forma rápida e confiável.
A esta transparência é essencial uma boa distribuição do serviço, sobre uma rede com baixa latência, ou o uso de técnicas que permitam esconder a latência.</p>
<hr />
<h5 id="escondendo-a-latencia">Escondendo a Latência</h5>
<ul>
<li><em>Caching</em> de dados <br>
  Em vez de sempre buscar os dados no servidor, mantenha cópias locais dos dados que mudam menos (e.g., o CSS do stackoverflow).</li>
<li>Use de comunicação assíncrona e paralelismo</li>
<li>Em vez de validar formulário após preenchimento de cada campo, valide em paralelo enquanto usuário preenche o campo seguinte.</li>
<li>Use um callbacks para indicar campos com problemas a serem corrigidos.</li>
<li>Nem todo problema é paralelizável, por exemplo, autenticação</li>
</ul>
<hr />
<p>Outra forma de diminuir latência é trazer para próximo do usuário parte da computação.
Isto é comumente feito com a interface com usuário,  mas pode ser usado também para outras partes do sistema. 
Como exemplo do primeiro, pense em consoles de video-game que fazem o processamento gráfico pesado na casa do usuário, de jogos online.
Como exemplo do segundo, pense em aplicativos que mantém os dados em celulares até que uma boa conexão, por exemplo WiFi, esteja disponível para sincronizar com o servidor.</p>
<hr />
<h5 id="escondendo-a-latencia_1">Escondendo a latência</h5>
<ul>
<li>Distribua tarefas</li>
<li>Delegue computação aos clientes<br>
    E.g., JavaScript e Applets Java.</li>
<li>Particione dados entre servidores<br>
    E.g., Domain Name Service e World Wide Web.</li>
<li>Aproxime dados dos clientes</li>
<li>Mantenha cópias de dados em múltiplos lugares.</li>
<li>Atualize dados de acordo com necessidade.<br>
    E.g., cache do navegador.</li>
</ul>
<h3 id="transparencia-de-relocacao">Transparência de Relocação</h3>
<p>As vezes os objetos precisam ser movimentados de uma localização à outra.
Se implementadas corretamente, as técnicas que entregam transparência de localização não deixam que o cliente perceba a movimentação, no que chamamos transparência de Relocação.</p>
<hr />
<h5 id="transparencia-localizacao-e-relocacao">Transparência Localização e Relocação</h5>
<ul>
<li>Rede de baixa latência</li>
<li>Distribuição inteligente</li>
<li>E.g: Serviços de nome</li>
<li>Múltiplas cópias</li>
<li>Cópias temporárias</li>
</ul>
<hr />
<h3 id="transparencia-de-migracao">Transparência de Migração</h3>
<p>Do ponto de vista do próprio serviço, não perceber que se está sendo movimentado é chamado transparência de Migração.
Um serviço com esta propriedade, não precisa ser parado e reconfigurado quando a mudança acontece.
Uma das formas de se implementar esta propriedade é através da migração provida por máquinas virtuais, usado, por exemplo, para consolidar o uso de servidores em nuvens computacionais.</p>
<hr />
<h5 id="transparencia-de-migracao_1">Transparência de Migração</h5>
<p><img alt="http://hyaking.com/wp-content/uploads/2017/01/Hyaking_Image_vmware-vmotion.jpg" src="images/vmotion.jpg" /></p>
<hr />
<p>Na verdade, a movimentação neste cenário, é uma cópia da máquina virtual. Uma vez que a cópia esteja próxima do fim, a imagem original é congelada, a cópia concluída, e há um chaveamento na rede para se direcionar toda comunicação para nova cópia. O máquina original é então descartada.</p>
<h3 id="transparencia-de-replicacao">Transparência de Replicação</h3>
<p>A capacidade de ter cópias de um serviço e de direcionar trabalho de uma para outra é também útil para se obter transparência no caso de falhas.
Isto porquê para se manter um serviço funcional a despeito de falhas, é preciso ter múltiplas cópias, prontas para funcionar a qualquer momento.</p>
<p>Dependendo das garantias desejadas na manutenção da <strong>consistência</strong> entre as cópias, o custo pode varia muito, de forma que para se ter um custo menor, tem-se garantias mais fracas, por exemplo, que as réplicas tem um <strong>atroso</strong> entre elas de $X$ minutos. Este é um dilema parecido com o TCP x UDP, em que mais garantias implicam em maior custo de comunicação.</p>
<p>Algumas aplicações toleram inconsistências e podem viver com menores custos. Um exemplo famoso é o dos "carrinhos de compra" da <a href="https://www.allthingsdistributed.com/2008/12/eventually_consistent.html">Amazon.com</a>, que podem fechar pedidos com conteúdo diferente do desejado pelo cliente.</p>
<p>Outras aplicações são normalmente construídas com requisitos de consistência forte entre as réplicas, como sistemas financeiros.
Para estas aplicações, uma técnica importante para se conseguir replicação é o uso de frameworks de comunicação em grupo, que entregam para múltiplas instâncias de um mesmo serviço, as mesmas mensagens, permitindo que elas se mantenham como cópias.
Esta técnica funciona se os serviços forem máquinas de estado determinísticas, que consideram como eventos as mensagens entregues pelo protocolo de comunicação em grupo.</p>
<hr />
<h5 id="maquina-de-estados">Máquina de Estados</h5>
<ul>
<li>Comunicação em grupo</li>
<li><img alt="https://i.stack.imgur.com/YHIVL.gif" src="images/state_machine.gif" /></li>
<li>Máquina de Estados Replicada</li>
</ul>
<hr />
<hr />
<h5 id="replicacao-x-inconsistencias">Replicação x Inconsistências</h5>
<ul>
<li>Múltiplas cópias <img alt="" src="images/rightarrow.png" /> em sincronização <img alt="" src="images/rightarrow.png" /> custos</li>
<li>Dado precisa ser consistente entre réplicas (mesmo valor em todo lugar) </li>
<li>Protocolos de invalidação de cache.</li>
<li>Muita largura de banda.</li>
<li>Baixa latência.</li>
</ul>
<hr />
<h3 id="transparencia-de-concorrencia">Transparência de Concorrência</h3>
<p>Outra transparência almejável é de concorrência. 
Isto é, quem acessa um serviço deveria ser indiferente ao fato de que o mesmo pode estar sendo acessado por outros.
Isto é importante tanto em termos de segurança, no sentido de que um cliente não deveria acessar os dados do outro, caso isso seja um requisito do sistema, quanto tem termos de desempenho.
Novamente, nuvens computacionais são um exemplo de onde este tipo de transparência é essencial.</p>
<p>Considere um serviço de banco de dados em uma nuvem qualquer. Para prover a mesma interface com a qual usuários estão acostumados a anos, é possível que este serviço seja simplesmente um <em>wrapper</em> ao redor do SGBD que se comprava e instalava <em>in-house</em> anteriormente.
Para se tornar viável, contudo, uma mesma instância deve servir múltiplos clientes, os <em>tenants</em>, sem que a carga de trabalho introduzida por um, interfira no desempenho do outro. No meio, chamamos esta propriedade de <em>multi-tenancy</em>, mas é apenas um exemplo de transparência de concorrência.</p>
<hr />
<h5 id="multi-tenancy">Multi-tenancy</h5>
<ul>
<li><img alt="https://cdn.jjude.com/mt-models.png" src="images/multitenancy_models.png" /></li>
</ul>
<hr />
<p>Esta propriedade está fundamentalmente ligada à escalabilidade, isto é, à adequação dos pool de recursos às demandas dos clientes: se mais clientes estão presentes, então aumente a quantidade de servidores e separe as cargas; se menos clientes estão presentes, então desligue algumas máquinas e economize recursos.</p>
<hr />
<h5 id="transparencia-concorrencia">Transparência Concorrência</h5>
<ul>
<li>controle de concorrência adequado.</li>
<li>mecanismos para alcançar <em>escalabilidade</em> (particionamento/<em>sharding</em>)</li>
</ul>
<hr />
<h3 id="desafios-para-se-obter-transparencia">Desafios para se obter transparência</h3>
<p>Apesar de desejáveis, as transparência discutidas são difíceis de se conseguir, principalmente se em conjunto.
Isto porquê, do <strong>ponto de vista de usuários</strong> espalhados pelo globo, atrás de redes heterogêneas e com possibilidade de erros, acontecerão atrasos e perdas na comunicação, denunciando a distribuição.</p>
<p>Do <strong>ponto de vista do desenvolvedor</strong>, é preciso tomar decisões baseado em premissas ligadas à realidade da rede. Por exemplo, se uma requisição não foi respondida, quanto tempo um cliente deve esperar antes de reenviá-la, possivelmente para outro servidor, sem incorrer em risco significativo da requisição ser processada duas vezes? A resposta para esta pergunta é muito mais complicada do que pode parecer.</p>
<p><strong>De forma geral</strong>, qualquer aumento de transparência tem um custo, seja em termos monetários (e.g., contratação de link dedicado ou de host em outra posição geográfica), ou em termos de desempenho (e.g., coordenar a entrega de mensagens em sistemas de comunicação em grupo).</p>
<p>Provavelmente os maiores obstáculos para se alcançar os diversos tipos de  transparência são impostos pela parte da infraestrutura que torna o sistema distribuído possível, a rede.
Para entender o porquê, vejamos algumas premissas normalmente assumidas sobre a rede que não são, definitivamente, verdade.</p>
<hr />
<h5 id="armadilhas-da-rede">Armadilhas da rede</h5>
<ul>
<li>A latência é zero.</li>
<li>A largura de banda é infinita.</li>
<li>A rede é confiável.</li>
<li>A rede é segura.</li>
<li>A rede é homogênea.</li>
<li>A rede é estática.</li>
<li>A rede tem acesso grátis.</li>
<li>A rede é administrada por você ou alguém acessível.</li>
</ul>
<hr />
<p>Para terminar, deixem-me apenas retomar um termo usado acima, <strong>escalabilidade</strong>.
O termo está muito em voga e é usado, normalmente, para descrever a capacidade de um sistema de se adequar a variações de carga de trabalho.
Embora seja um uso válido, há outros tipos de escalabilidade.</p>
<hr />
<h5 id="escalabilidade">Escalabilidade</h5>
<ul>
<li>Escalabilidade</li>
<li>Tamanho: Número de usuários que suporta.</li>
<li>Geográfica: Região que cobre.</li>
<li>Administrativa: Número de domínios administrativos.</li>
<li>Há várias possibilidades: seja específico e exija especificidade.</li>
</ul>
<hr />
<p>layout: default
title: Tipos
parent: Introdução
nav_order: 4</p>
<hr />
<h1 id="tipos-e-arquiteturas">Tipos e Arquiteturas</h1>
<p>Diversos são as finalidades dos sistemas distribuídos que construímos, assim como são diversas as arquiteturas que usamos.
Classificar os tipos e arquiteturas nos ajuda a pensar sobre sistemas e a encontrar e reusar soluções previamente testadas. </p>
<h2 id="tipos">Tipos</h2>
<h3 id="sistemas-de-computacao-high-performance-computing">Sistemas de Computação - High Performance Computing</h3>
<p>A possibilidade de agregar poder de processamento de muitos computadores em um rede de comunicação com altíssima largura de banda nos permite atacar problemas computacionalmente muito intensos.
Clusters como o da imagem a seguir são compartilhados por pesquisadores resolvendo problemas áreas como bio-informática, engenharia, economia, inteligência artificial, etc.</p>
<p><img alt="Cluster para HPC no High Performance Computing Center de Stuttgart" src="https://upload.wikimedia.org/wikipedia/commons/9/9e/High_Performance_Computing_Center_Stuttgart_HLRS_2015_08_Cray_XC40_Hazel_Hen_IO.jpg" /></p>
<p>Na engenharia, por exemplo, HPC pode ser usada para testar a eficiência de projetos sem construir protótipos, seja
* de uma turbina <br>
<img alt="CFD" src="images/turbine.jpeg" />
* um carro <br>
<img alt="CFD" src="images/cfd_car.jpg" />
* ou uma vaca <br>
<img alt="CFD" src="images/CFD_Cow.jpg" /></p>
<h3 id="sistemas-de-informacao">Sistemas de Informação</h3>
<p>Provavelmente mais comuns entre os profissionais da computação, os sistemas de informação distribuídos permitem a são encontrados em diversas formas (de fato, o termo "sistema de informação" é tão abrangente, que dificilmente um sistema distribuído não estaria nesta classe.).</p>
<p>O seguinte é um exemplo de uma arquitetura em três camadas, onde a primeira camada faz interface com o usuário, a segunda camada contém a lógica do negócio, e a terceira camada mantem os dados.</p>
<p><a href="https://en.wikipedia.org/wiki/Multitier_architecture"><img alt="3 Tier" src="images/3tier.png" /></a></p>
<p>Peça fundamental desta abordagem, os bancos de dados na terceira camada são, muito frequentemente, transacionais.
Isto é, eles provêem as seguintes garantias na execução de transações, as famosas propriedades ACID:</p>
<hr />
<ul>
<li>Atomicidade: transações são tratadas de forma indivisível, isto é, ou tudo ou nada.</li>
<li>Consistência: transações levam banco de um estado consistente a outro<br>
    E.g., x == 2*y</li>
<li>Isolamento: transações não vêem dados não comitados umas das outras.</li>
<li>Durabilidade: os efeitos de uma transação comitada devem persistir no sistema a despeito de falhas.</li>
</ul>
<hr />
<p>Para relembrar o que querem dizer as propridades, considere a seguinte sequência de operações:</p>
<p>```
1: a = SELECT X
2: c = a * 2
3: b = c + 10
4: SET X=c
5: SET Y=b
````
Suponha duas instâncias desta sequência, $T_1$ e $T_2$, concorrentes, em que as operações escalonadas da seguinte forma, onde $T_x^y$ é a y-ésima operação de $T_x$.</p>
<p>$T_1^1, T_1^2, T_1^3, T_1^4, T_2^1, T_2^2, T_2^3, T_2^4, T_2^5, T_1^5$</p>
<p>Ao final da execução, X terá o valor atribuído por $T_2$, mas $Y$ terá o valor de $T_1$. 
Este escalonamento violou a consistência do banco de dados por quê as operações não foram executadas isoladamente.</p>
<p>Tente imaginar a dificuldade de se implementar um banco de dados distribuído. Isto é, um banco em que vários nós mantem os dados, participam de transações e, portanto, precisam coordenar-se para manter os dados consistentes. A figura abaixo mostra um cenário com três bancos. Imagine que em um deles está uma relação com os dados dos clientes. Em outro, os dados do estoque. Finalmente, no terceiro nó, temos ordens de compra. Quando um cliente faz um pedido, o cliente deve ser validado no primeiro nó, o item é removido do estoque no segundo nó, e no terceiro é disparada uma cobrança para o cliente. Se qualquer destas três relações não for corretamente consultada e alterada, os efeitos podem ser catastróficos para o negócio.</p>
<p><img alt="01-10" src="images/01-10.png" /></p>
<p>Como implementar ACID neste banco de dados? Embora veremos isso um pouco mais para frente neste material, por enquanto, apenas assuma que não é exatamente fácil ou barato. Esta dificuldade foi a razão do surgimento dos bancos de dados NOSQL (née NoSQL).</p>
<p><img alt="https://www.algoworks.com/blog/nosql-database/" src="images/nosql.jpeg" /></p>
<p>Em tempo, discutiremos como estes bancos de dados funcionam, quando falarmos sobre sistemas P2P.</p>
<h4 id="integracao-de-aplicacoes">Integração de Aplicações</h4>
<p>Frequentemente é necessário integrar sistemas de informação legados com sistemas mais modernos, ou simplesmente expô-los usando uma interface mais moderna. Nestes casos, pode ser possível integrar diversos sistemas usando um <em>middleware</em> que os encapsule.</p>
<p><img alt="01-11" src="images/01-11.png" /></p>
<p>O <em>middleware</em> pode, por exemplo, se expor via interface REST para os clientes, mas consultar o sistema legado em um padrão antigo.</p>
<p>Outro exemplo é o sistema na imagem seguinte, que mostra diversos departamentos de um empresa conversando via troca de mensagens. Observe que nenhum departamento precisa conversar diretamente com os outros, ou mesmo conhecê-los. Eles apenas publicam a mensagem para quem puder tratar. Da mesma forma, a resposta vem na forma de uma mensagem.</p>
<p><img alt="https://www.codeproject.com/articles/297162/introducing-expert-systems-and-distributed-archite" src="images/mq.png" /></p>
<p>Siga este <a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">link</a> para ler mais sobre este tipo de sistema.</p>
<h3 id="sistemas-pervasivosubiquos">Sistemas Pervasivos/Ubíquos</h3>
<p>Segundo Weiser, 1993</p>
<blockquote>
<p>Ubiquitous computing is the method of enhancing computer use by making many computers available throughout the physical environment, but making them effectively invisible to the user".</p>
</blockquote>
<p>O que é importante aqui é o foco na tarefa em vez de na ferramenta. Assim, sistemas pervasivos devem ajudar as pessoas a realizar suas tarefas, de forma implícita, sem ter que pensar em como a tarefa será executada.
Para que seja realizada, a computação pervasiva requer que dispositivos <strong>detectem o contexto*<em> em que estão inseridos, *<em>combinem-se de forma </em>ad-hod</em></strong> e <strong>compartilhem informações</strong>.</p>
<p>Alguns exemplos interessantes de computação pervasiva.</p>
<h4 id="smart-life">Smart Life</h4>
<iframe width="560" height="315" src="https://www.youtube.com/embed/M08fVm6zVyw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h4 id="amazon-go">Amazon Go</h4>
<iframe width="560" height="315" src="https://www.youtube.com/embed/zdbumR6Bhd8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h4 id="minority-report">Minority Report</h4>
<p>E, para quem já viu Minority Report, aqui vai um reality check.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/RJ4KxaWraJc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h4 id="redes-de-sensores-e-internet-das-coisas">Redes de Sensores e Internet das Coisas</h4>
<p>Eu vou me arriscar colocando Redes de Sensores e Internet das Coisas como uma subsessão de Sistemas Pervasivos.
Isto porquê, a meu ver, as redes de sensores são parte da infraestrutura para se obter sistemas pervasivos; são os sensores que percebem mudanças contexto e "leêm" o estado do contexto atual e alimentam outros sistemas que reagem a tal estado.
A Internet das Coisas (IoT, do inglês *Internet of Things) vai também na mesma linha, levando à integração entre sensores, atuadores, e outros dispositivos que nos servem, em um ambiente de computação pervasiva.
"Mas se é assim, qual o risco?", você pergunta. Bem, a Internet das Coisas pode ser vista como algo além dos sistemas pervasivos, pois se estes últimos são focados nos humanos em um certo contexto, a IoT não necessariamente foca-se nos humanos, mas na realização de alguma tarefa. 
Por exemplo, um sistema de irrigação que percebe o nível de humidade do ar, analisa previsões de chuva e decide em quanto irrigar uma plantação de laranjas provavelmente não se importará com a presença ou não de um humano na plantação.</p>
<p><img alt="https://www.edureka.co/blog/iot-applications/" src="images/iot1.png" /></p>
<p>Para ler mais sobre IoT, veja este <a href="https://publications.europa.eu/en/publication-detail/-/publication/ed079554-72c3-4b4e-98f3-34d2780c28fc">link</a> que descreve diversos projetos europeus na área.</p>
<h1> TODO Alguns exemplos de IoT e redes de sensores</h1>

<ul>
<li>Smart grid e lavadora que escolhe horário</li>
<li>Termostatos que percebem movimento</li>
<li>Fechaduras que se abrem quando o dono se aproxima</li>
<li>Movimentação de tropas e de fauna</li>
<li>Índices de poluição</li>
<li>Abalos sísmicos e predição de avalanches</li>
<li><a href="https://beebom.com/examples-of-internet-of-things-technology/">link</a></li>
</ul>
<h4 id="uma-nota-sobre-privacidade-nos-sistemas-pervasivos">Uma nota sobre privacidade nos sistemas pervasivos</h4>
<p>À medida em que aumentamos o ambiente ao nosso redor ou a nós mesmos com dispositivos computacionais, por um lado facilitamos nossa vida pois somos assistidos por tais dispositivos, mas por outro, nos tornamos cada vez mais dependentes nos mesmos, com sérios riscos à nossa privacidade.
Isto ocorre por que para que realizem suas tarefas, os sistemas pervasivos precisam de cada vez mais informações sobre nós, e há sempre o risco de que estas informações sejam usadas de forma que não nos apetece.</p>
<h1> TODO Exemplos de problemas de privacidade. </h1>

<ul>
<li><a href="https://www.nytimes.com/2017/07/25/technology/roomba-irobot-data-privacy.html">Roomba mapeando sua casa</a>.</li>
<li>Ghost in the shell</li>
<li>Snow crash (Neil Stephenson)</li>
</ul>
<h3 id="computacao-utilitaria">Computação Utilitária</h3>
<p>Um tipo importante de sistema distribuído mais recente são as nuvens computacionais, usadas no provimento de computação utilitária.
Este tipo de sistema, embora possa ser pensando como infraestrutura para outros sistemas distribuídos, são, na verdade, complexas peças de engenharia, com diversos subsistemas responsáveis por sincronização de relógios, monitoração de falhas, coleta de logs, roteamento eficiente tolerante a falhas e por aí vai.</p>
<p>O seguinte vídeo mostra, em 360 graus, um dos datacenters do Google, para que você tenha ideia da escala em que estes sistemas são construídos.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/zDAYZU4A3w0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Para uma viagem fotográfica, siga este <a href="https://www.google.com/about/datacenters/gallery/#/all">link</a></p>
<h2 id="arquiteturas">Arquiteturas</h2>
<p>De acordo com David Garlan and Mary Shaw, January 1994, CMU-CS-94-166, em <a href="http://www.cs.cmu.edu/afs/cs/project/able/ftp/intro_softarch/intro_softarch.pdf"><em>An Introduction to Software Architecture</em></a></p>
<blockquote>
<p>... an architectural style determines the vocabulary of components and connectors that can be used in instances of that style, together with a set of constraints on how they can be combined. These can include topological constraints on architectural descriptions (e.g., no cycles). Other constraints—say, having to do with execution semantics—might also be part of the style definition.</p>
</blockquote>
<p>Em outras palavras, um estilo ou padrão arquitetural é o conjunto de princípios que provê uma infraestrutura abstrata para uma família de sistemas, e promove o reuso de projeto ao <a href="https://msdn.microsoft.com/en-us/library/ee658117.aspx">prover soluções para problemas recorrentes e frequentes</a>.</p>
<h3 id="componentes-e-conectores">Componentes e Conectores</h3>
<p>Quando falamos sobre arquiteturas em sistemas distribuídos, estamos primariamente focados na forma como componentes se conectam, por meio de conectores, para implementar a solução para um problema.</p>
<p><img alt="Componentes e Conectores" src="images/components.png" /></p>
<p>Dependendo de como são conectados, haverá maior ou menor dependência entre os componentes.
Quando houver forte dependência, diremos que os componentes estão <strong>fortemente conectados</strong> (<em>tightly coupled</em>). Caso contrário, diremos que estão <strong>fracamente conectados</strong> (<em>loosely coupled</em>).
A razão óbvia para preferir sistemas fracamente conectados é sua capacidade de tolerar disrupções; se um componente depende pouco de outro, então não se incomodará com sua ausência por causa de uma falha.</p>
<p>Certos <em>middleware</em> permitem um acoplamento tão fraco entre componentes, que estes não precisam se conhecer ou sequer estarem ativos no mesmo momento.</p>
<p><img alt="Desacoplamento" src="images/component2.png" /></p>
<p>Também a questão da simplificação de API, uma vez que o <em>middleware</em> pode impor um padrão a ser seguido por todos os componentes, e com isso minimizar a necessidade os componentes conhecerem as interfaces uns dos outros.</p>
<p><img alt="https://dzone.com/articles/the-importance-of-loose-coupling-in-rest-api-desig" src="images/loosetight.png" /></p>
<h3 id="clienteservidor">Cliente/Servidor</h3>
<p>A forma como os componentes se comunicam, isto é, os conectores usados, é importante no estudo arquitetural. Mas também são importantes os papéis assumidos pelos componentes na realização de tarefas.
Neste sentido, provavelmente a arquitetura de computação distribuída mais famosa é a <strong>Cliente/Servidor</strong>.</p>
<p>Na arquitetura Cliente/Servidor, como implicado pelo nome, há um processo que serve a pedidos realizados por outros processos. 
Isto é feito quando o <strong>cliente</strong> o contacta o servidor e requer (<em>request</em>) a realização do serviço.
O <strong>servidor</strong>, por sua vez, pode desempenhar tarefas como fazer cálculos, armazenar dados, ou repassar uma mensagem e, ao final da realização da tarefa, responder (<em>response</em>) ao cliente.</p>
<p>Um mesmo servidor pode atender a diversos clientes e, geralmente, a comunicação entre os mesmos é feita diretamente por sockets.</p>
<p><img alt="http://psspol.blogspot.com.br/2015/07/difference-between-client-server.html" src="images/cs.png" /></p>
<p>Embora seja possível usar sockets de forma assíncrona, a API mais comum é síncrona, isto é, quando um processo espera receber uma mensagem de outro, ele fica bloqueado esperando algum dado estar disponível para leitura no referido socket.
Assim, geralmente a comunicação entre cliente e servidor segue o seguinte esquema:</p>
<p><img alt="02-03" src="images/02-03.png" /></p>
<p>Observe que o cliente fica inativo enquanto espera a resposta e que o servidor fica inativo enquanto espera outras requisições.
Para minimizar os períodos de inatividade, o cliente pode usar o socket assíncronamente, o que não é exatamente simples, ou usar múltiplos threads, para que continue operando mesmo enquanto um thread estiver bloqueado esperando a resposta do servidor.</p>
<p>No lado do servidor, o minimização da ociosidade é feita pelo uso de múltiplos clientes, concorrentes, e também pelo uso de múltiplos threads.
Neste caso, contudo, é necessário tomar muito cuidado para garantir que a concorrência não causará efeitos indesejados nos dados e execução das tarefas.
Veja o caso de um banco de dados transacional, por exemplo, como discutido acima; ele precisa garantir ACID entre as transações propostas pelos clientes.</p>
<p>Embora tenhamos colocado aqui apenas um servidor atendendo aos clientes, em muitas aplicações modernas, múltiplos servidores atenderão ao conjunto de clientes.
Pense por exemplo no serviço de email do Google, o Gmail. Com os milhões de usuários que tem, certamente há mais de um servidor implementando o serviço.
Provavelmente estes diversos servidores ficam atrás do que chamamos de um balanceador de cargas, que roteia as requisições seguindo diferentes políticas, por exemplo, <em>round robin</em>.</p>
<p><img alt="http://blogs.softchoice.com/itgrok/client/one-egg-many-baskets/" src="images/lb.jpg" /></p>
<h3 id="par-a-par-p2p">Par-a-Par (P2P)</h3>
<p>Diferentemente de sistemas cliente/servidor, em que um nó serve o outro, em sistemas par-a-par, nos nós são parceiros e tem igual responsabilidade (e daí o nome) na execução das tarefas.</p>
<p>Diversos sistemas P2P existem, sendo, provavelmente, os mais famosos, os sistemas de compartilhamento de arquivos.
Nesta linha, embora diversos tenham existido, hoje o mais famoso é o Bittorrent, embora, como veremos adiante, o mesmo não seja exatamente P2P.</p>
<p>Outro exemplo importante por ter inspirado diversos outros sistemas é o Chord. 
Neste sistema, nós organizam-se em um anel lógico e cada um se torna responsável por um dos segmentos do anel adjacente a onde se encontra no mesmo.
Requisições para correspondentes a um segmento são roteados para o nó responsável usando uma tabela de rotas conhecida como <em>finger table</em>.
Se traçarmos os caminhos apontados por esta tabela sobre o anel, desenharemos <strong>cordas</strong> sobre o mesmo, o que explica o nome do sistema.</p>
<p><img alt="Chord" src="images/chord.png" /></p>
<h3 id="hibridos">Híbridos</h3>
<p>Embora cliente/servidor e P2P sejam arquiteturas clássicas, boa parte dos sistemas que distribuídos podem ser na verdade consideradas híbridos.
Considere um sistema de email, por exemplo. Embora clientes usem as funcionalidades dos servidores de email para enviar e receber mensagens, os servidores conversam uns com os outros para implementar a tarefa de encaminhar as mensagens. Neste sentido, o sistema é um híbrido P2P e cliente/servidor.</p>
<p>Outros exemplos abundam.</p>
<ul>
<li>Bancos de dados, e.g., DynamoDB, <a href="https://www.atlassian.com/blog/archives/do-you-know-cassandra">CassandraDB</a>, Redis,...</li>
<li>Jogos multiplayer (pense no <a href="http://pages.cs.wisc.edu/~vshree/cs740/Voronoi.pdf">particionamento dos mapas</a>)</li>
<li>Compartilhamento de arquivos: Bittorrent</li>
</ul>
<p>Considere este último exemplo, do Bittorrent. Observe na figura adiante os diversos passos necessários à recuperação do arquivo de interesse.</p>
<p><img alt="Bittorrent" src="images/bittorrent.png" /></p>
<p>Voltando ao exemplo do sistema de informação, observe que o cliente acessa um serviço, implementado por pares de nós. 
Podemos dizer que também este é híbrido.</p>
<p><img alt="01-10" src="images/01-10.png" /></p>
<h3 id="sistemas-multi-camadas">Sistemas multi-camadas</h3>
<p>Outra forma de hibridismo que podemos citar é quando um componente haje tanto como cliente quanto como servidor. 
Veja o seguinte exemplo, conhecido no meio como arquitetura em 3-camadas (3 <em>tiers</em>).</p>
<p><a href="https://managementmania.com/en/three-tier-architecture"><img alt="3 Tiers" src="images/3tierb.gif" /></a></p>
<p>Neste caso, é interessante notar que esta disposição dos componentes é independente da disposição física. De fato, as três camadas podem estar em um mesmo nó, ou combinadas duas a duas, neste último caso resultando em duas camadas.</p>
<p><img alt="2 Tiers" src="images/02-05.png" /></p>
<p>Por outro lado, cada camada pode ser subdividida em mais componentes, resultando é múltiplos tiers, como neste exemplo de um sistema de busca na Web.</p>
<p><img alt="Multi-tier" src="images/02-04.png" /></p>
<h3 id="micro-servicos">Micro-serviços</h3>
<p>Finalmente, chegamos aos sistemas micro-serviços, em que os sistemas existem independentemente, cada um com suas camadas e cada um resolvendo um problema em específico, mas todos contribuindo para a realização de uma tarefa maior.</p>
<p><img alt="Microserviços" src="images/microservice_sample.png" /></p>
<p>Nós discutiremos micro-serviços mais adiante. Por agora, apenas tenha em mente que embora seja vendido por muitos como tal, <a href="http://www.zdnet.com/article/microservices-101-the-good-the-bad-and-the-ugly/">os micro-serviços não são uma panacéia</a>.</p>
<h2 id="para-aprender-mais">Para aprender mais</h2>
<p>Para aprender mais sobre arquiteturas, consulte a seguinte referência: <a href="https://keetmalin.wixsite.com/keetmalin/single-post/2017/09/27/Distributed-System-Architectures-and-Architectural-Styles">Distributed System Architectures and Architectural Styles</a>.</p>
<p>Para aprender um pouco sobre como funcionam as redes de um datacenter, definidas por software, assista ao seguinte vídeo, que fala sobre a infra-estrutura do Facebook.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/mLEawo6OzFM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href=".." class="btn btn-neutral" title="Prólogo"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
