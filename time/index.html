
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.1.6">
    
    
      
        <title>Tempo - Notas em Sistemas Distribuídos</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.6910b76c.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.196e0c26.min.css">
        
      
    
    
    
      
        
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
        
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-PJX835H7DP","lasarojc.github.org/dsnotes"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}),document.addEventListener("DOMContentSwitch",function(){ga("send","pageview",document.location.pathname)})</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
      
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#tempo" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href=".." title="Notas em Sistemas Distribuídos" class="md-header-nav__button md-logo" aria-label="Notas em Sistemas Distribuídos">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            Notas em Sistemas Distribuídos
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Tempo
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Notas em Sistemas Distribuídos" class="md-nav__button md-logo" aria-label="Notas em Sistemas Distribuídos">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Notas em Sistemas Distribuídos
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." class="md-nav__link">
      Prólogo
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../intro/" class="md-nav__link">
      Introdução
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../basics/" class="md-nav__link">
      Fundamentos
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../comm/" class="md-nav__link">
      Comunicação
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../arch/" class="md-nav__link">
      Arquiteturas
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../coord/" class="md-nav__link">
      Coordenação
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Tempo
        <span class="md-nav__icon md-icon"></span>
      </label>
    
    <a href="./" class="md-nav__link md-nav__link--active">
      Tempo
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#tempo-fisico" class="md-nav__link">
    Tempo Físico
  </a>
  
    <nav class="md-nav" aria-label="Tempo Físico">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#relogios-de-quartzo-e-atomicos" class="md-nav__link">
    Relógios de Quartzo e Atômicos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tempo-universal-coordenado" class="md-nav__link">
    Tempo Universal Coordenado
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sincronizacao-de-relogios" class="md-nav__link">
    Sincronização de Relógios
  </a>
  
    <nav class="md-nav" aria-label="Sincronização de Relógios">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#global-positioning-system" class="md-nav__link">
    Global Positioning System
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algoritmo-de-cristian" class="md-nav__link">
    Algoritmo de Cristian
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algoritmo-de-berkeley" class="md-nav__link">
    Algoritmo de Berkeley
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#network-time-protocol" class="md-nav__link">
    Network Time Protocol.
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ptp-precision-time-protocol" class="md-nav__link">
    PTP - Precision Time Protocol
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#usos-de-relogios-sincronizados" class="md-nav__link">
    Usos de relógios sincronizados
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tempo-logico" class="md-nav__link">
    Tempo Lógico
  </a>
  
    <nav class="md-nav" aria-label="Tempo Lógico">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#happened-before" class="md-nav__link">
    Happened-Before
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relogios-logicos" class="md-nav__link">
    Relógios lógicos
  </a>
  
    <nav class="md-nav" aria-label="Relógios lógicos">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#relogio-de-lamport" class="md-nav__link">
    Relógio de Lamport
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relogio-vetorial" class="md-nav__link">
    Relógio Vetorial
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relogios-hibridos" class="md-nav__link">
    Relógios Híbridos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comunicacao-em-grupo" class="md-nav__link">
    Comunicação em Grupo
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exclusao-mutua-revisitada" class="md-nav__link">
    Exclusao Mútua Revisitada
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../fault/" class="md-nav__link">
      Tolerância a Falhas
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../disdb/" class="md-nav__link">
      Bancos de Dados
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../disfs/index.md" class="md-nav__link">
      Sistemas de Arquivos
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../tech/" class="md-nav__link">
      Tecnologias
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../projeto/" class="md-nav__link">
      Projeto
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#tempo-fisico" class="md-nav__link">
    Tempo Físico
  </a>
  
    <nav class="md-nav" aria-label="Tempo Físico">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#relogios-de-quartzo-e-atomicos" class="md-nav__link">
    Relógios de Quartzo e Atômicos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tempo-universal-coordenado" class="md-nav__link">
    Tempo Universal Coordenado
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sincronizacao-de-relogios" class="md-nav__link">
    Sincronização de Relógios
  </a>
  
    <nav class="md-nav" aria-label="Sincronização de Relógios">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#global-positioning-system" class="md-nav__link">
    Global Positioning System
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algoritmo-de-cristian" class="md-nav__link">
    Algoritmo de Cristian
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algoritmo-de-berkeley" class="md-nav__link">
    Algoritmo de Berkeley
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#network-time-protocol" class="md-nav__link">
    Network Time Protocol.
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ptp-precision-time-protocol" class="md-nav__link">
    PTP - Precision Time Protocol
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#usos-de-relogios-sincronizados" class="md-nav__link">
    Usos de relógios sincronizados
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tempo-logico" class="md-nav__link">
    Tempo Lógico
  </a>
  
    <nav class="md-nav" aria-label="Tempo Lógico">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#happened-before" class="md-nav__link">
    Happened-Before
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relogios-logicos" class="md-nav__link">
    Relógios lógicos
  </a>
  
    <nav class="md-nav" aria-label="Relógios lógicos">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#relogio-de-lamport" class="md-nav__link">
    Relógio de Lamport
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relogio-vetorial" class="md-nav__link">
    Relógio Vetorial
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relogios-hibridos" class="md-nav__link">
    Relógios Híbridos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comunicacao-em-grupo" class="md-nav__link">
    Comunicação em Grupo
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exclusao-mutua-revisitada" class="md-nav__link">
    Exclusao Mútua Revisitada
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="tempo">Tempo</h1>
<p>Neste capítulo discutiremos como o <strong>tempo</strong> é importante no desenvolvimento de sistemas distribuídos.
Comecemos por analisar o funcionamento de uma aplicação distribuída muito comum, o armazenamento de arquivos na nuvem, sincronizado com o sistema de arquivos local. 
Alguns exemplos do mundo real são Dropbox, Box, Google Drive and OneDrive; chamemos este serviço genericamente de <strong>cloud-drive</strong>.</p>
<p><img alt="Cloud Drive" src="drawings/cloud_drive.drawio-0.svg" /></p>
<p>Se um mesmo arquivo no cloud-drive é modificado em duas máquinas diferentes, enquanto as mesmas estão desconectadas, o quê acontece quando elas se reconectam à Internet?
Mais especificamente, quando as duas máquinas se conectam e enviam suas versões do arquivo modificado para o servidor, sendo que ambas foram geradas a partir de um ancestral comum, qual versão deve ser armazenada e qual deve ser descartada?</p>
<p>Uma possibilidade simples é sempre aceitar cada nova versão como uma modificação do arquivo.
Assim, efetivamente, quando a primeira versão for entregue, será aceita e viverá momentaneamente até que a outra versão seja recebida e a sobrescreva.
No exemplo seguinte, o resultado é o mesmo que no exemplo anterior, sem falhas.</p>
<p><img alt="Cloud Drive" src="drawings/cloud_drive.drawio-1.svg" /></p>
<p>Contudo, se estendermos um pouco mais a descontividade do nó na parte de cima, o resultado final se inverte.</p>
<p><img alt="Cloud Drive" src="drawings/cloud_drive.drawio-2.svg" /></p>
<p>No Exemplo, entre as entregas da "Versão B" e "Versão A" para o servidor no centro do diagrama, vale a "Versão B".
Também pelo gráfico, vemos que a "Versão B" foi criada <strong>depois</strong> da "Versão A", mas que a versão final vista pelo servidor é exatamente a "A". 
Logo, questionamos se esta abordagem é correta.
Afinal ordem de chegada ao servidor não serve como critério para escolha, afinal, a ordem de chegada dos arquivos ao servidor não reflete necessariamente a ordem em que os arquivos foram criados.</p>
<p>Assim, podemos pensar em outras alternativas de aproveitamento e descarte de arquivos baseadas na <strong>criação</strong> do arquivo. Contudo, o horário de criação de um arquivo é relativo a onde foi criado e não ao grupo de processos que compõe o sistema, o que pode levar uma modificação que tenha acontecido mais tarde, do ponto de vista de um observador externo, a ter um horário de criação oficial anterior.</p>
<!--Uma terceira abordagem é gerar uma terceira versão, com a "soma" das duas conflitantes. Para gerar esta terceira versão, faz mais sentido quebrar os arquivos em *operações de modificação*, e executar as operações de forma a chegar ao resultado final. O problema permanece, pois as operações agora devem ser ordenadas. , a menos que façamos com que os processo concordem na passagem do tempo.-->

<p>Se for possível identificar a causalidade entre as modificações, isto é, qual versão originou qual outra, então é claro que se deve manter versões de acordo com a ordem causal.
Contudo, edições concorrentes, como a criação das versões A e B no exemplo anterior, não tem relação de causalidade entre si.</p>
<p>Assim,
em qualquer destas linhas de atuação, você tem em mãos um conflito para resolver, e automatizar a resolução do mesmo é muito complicado. É por isso que o Dropbox, por exemplo, deixa os dois arquivos para que o usuário analise e decida o que fazer, que servidores git exigem que o usuário pegue a versão salva mais recentemente e compatibilize suas mudanças com ela antes de submeter novas mudanças, e o Perforce trabalha com <em>locks</em>  de arquivos.</p>
<p>Se pensarmos em termos não de arquivos sendo enviados para um servidor, mas de operações de modificações sendo executadas, então dada esta problemática, podemos simplificar a questão em nossas mãos.</p>
<div class="admonition question">
<p class="admonition-title">Como ordenar operações de clientes?</p>
<p>Se duas operações originadas em clientes são enviadas ao servidor, qual deve ser executada primeiro?</p>
</div>
<p>Embora, como já vimos, usar a ordem temporal da criação das operações também seja problemático, já que relógios são dessincronizados em sistemas distribuídos típicos, alguns sistemas tentam resolver automaticamente os conflitos usando exatamente estes relógios. O CassandraDB, por exemplo, usa <strong><em>last write wins</em></strong> ou <strong><em>latest version wins</em></strong>, onde <strong><em>last</em></strong> é definido em termos do relógio do cliente.
Neste cenário, temos novo problema:</p>
<div class="admonition question">
<p class="admonition-title">Pergunta</p>
<p>Como determinar qual foi enviada primeiro, em um sistema assíncrono?</p>
</div>
<p>Para usar esta abordagem, precisamos encontrar uma <strong>fonte de tempo confiável e distribuída</strong>, construída pelo uso de protocolos de <strong>sincronização de relógios físicos</strong></p>
<h2 id="tempo-fisico">Tempo Físico</h2>
<p>Para falarmos sobre sincronização de relógios em um cenário distribuído, primeiro devemos entender como funcionam os relógios em nível de uma única máquina, isto é, seus relógios físicos e como são usados pelo sistema operacional.</p>
<h3 id="relogios-de-quartzo-e-atomicos">Relógios de Quartzo e Atômicos</h3>
<p>Quando falamos em relógios, provavelmente falamos sobre relógios a base de quartzo.
Para uma introdução rápida, assista o seguinte vídeo.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/3jfgQF3jX7A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Em suma, um relógio de quartzo consiste em um <strong>diapazão de quartzo</strong> cortado a laser que, devido ao <strong>efeito Piezoelétrico</strong><sup id="fnref:piezo"><a class="footnote-ref" href="#fn:piezo">2</a></sup> e sua forma particular, vibra a <span><span class="MathJax_Preview">32768 = 2^{15}</span><script type="math/tex">32768 = 2^{15}</script></span>Hz<sup id="fnref:freq"><a class="footnote-ref" href="#fn:freq">3</a></sup>, e em um contador que conta cada vibração, medindo a passagem do tempo.
Estes relógios erram na medição do tempo em no máximo <strong>&frac12;s por dia</strong>, desde que operem dentro da faixa de 5 a 35C, mas isso também muda com a idade do cristal, a corrente elétrica passando por ele e também devido a imperfeições no cristal<sup id="fnref:quartz"><a class="footnote-ref" href="#fn:quartz">1</a></sup>.</p>
<p>Computadores em geral usam relógios de quartzo, por serem baratos, como base de um relógio mantido em software.
Isto é, do ponto de vista de um computador comum, o tempo é medido com base em um relógio quartzo, cujos incrementos são capturados em um contador;
o contador gera <strong>interrupções em intervalos programados</strong> (e.g., Linux &gt;2.6 usa 250Hz por padrão; máximo 1000Hz) e as interrupções causam ajustes em um <strong>relógio em software</strong>, um contador indireto <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>.</p>
<div class="admonition question">
<p class="admonition-title">Precisão</p>
<p>Dado a frequência padrão de 250Hz, medições de tempo menores que 4ms são altamente imprecisas.
 Como medir o tempo gasto em uma função do seu código?</p>
</div>
<p>Este relógio em software, <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>, que usa um relógio de quartzo, impreciso, pode marcar a passagem do tempo com erro para mais ou para menos. Embora o erro exato do relógio seja desconhecido, o mesmo é limitado probabilisticamente. 
A taxa de erro é denominada <em>drift</em>, é representada por <span><span class="MathJax_Preview">\rho</span><script type="math/tex">\rho</script></span>.</p>
<p>Assumindo um relógio perfeito, <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>, temos que <span><span class="MathJax_Preview">1 - \rho \leq \frac{dC}{dt} \leq 1 + \rho</span><script type="math/tex">1 - \rho \leq \frac{dC}{dt} \leq 1 + \rho</script></span>.
Assim, um <span><span class="MathJax_Preview">\rho</span><script type="math/tex">\rho</script></span> de 0.1 implica em um erro de mais ou menos 10%; a figura a seguir mostra a faixa em que <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span> pode operar e que o erro em relação a <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> vai aumentando com a passagem do tempo.</p>
<p><img alt="Clock drift" src="drawings/clock_skew.drawio-0.svg" /></p>
<p>Embora adequado para humanos, o erro dos relógios de quartzo é inaceitável em algumas operações computacionais. 
Felizmente, os erros do destes relógios podem ser minimizados ao ponto de termos um erros menores que 1s em milhões de anos, nos dispositivos conhecidos como <strong>relógios atômicos</strong>.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/p2BxAu6WZI8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Embora muito bom, o relógio atômico também não é perfeito e, devido a várias razões, pode levar também a erros.
Mas o quê mais se pode fazer no sentido de melhorar a precisão dos relógios? A resposta está no UTC.</p>
<h3 id="tempo-universal-coordenado">Tempo Universal Coordenado</h3>
<p>O UTC, de uma mistura dos nomes em Inglês e Francês do Tempo Universal Coordenado, um padrão global para coordenação da medição da passagem do tempo.
Segundo o UTC, o sol está a pino às 12:00 na latitude 0, ou a no máximo 1s deste instante; ao redor da latitude 0 grau estabelece-se uma faixa em que todos os pontos tem o mesmo horário, e outras 23 faixas como esta com deslocamentos consecutivos de +-1 hora.
Estas faixas, conhecidas coloquialmente como fusos, sofrem ajustes por fatores políticos; a China, por exemplo, apesar de seu tamanho, está toda dentro de um mesmo horário, "correto" para Beijing.</p>
<p><img alt="Fuso-horários" src="images/TimeZones.png" /></p>
<p>Mas como o UTC é definido? Com base no TAI, Tempo Atômico Internacional, calculado como a média dos valores de relógios atômicos espalhados pelo globo. O TAI mede perfeitamente a passagem do tempo, mas como a rotação da terra é irregular, medir perfeitamente não é o adequado. Assim, o UTC leva em consideração o fato do dia não ter exatamente 24 horas e, de fato, não ter duração constante. Por exemplo, após um grande terremoto o centro de massa da terra pode ser alterado e a rotação ter sua velocidade aumentada ou diminuída.</p>
<div class="admonition quote">
<p class="admonition-title">UTC</p>
<p>Nearly all UTC days contain exactly 86,400 SI seconds with exactly 60 seconds in each minute. However, because the mean solar day is slightly longer than 86,400 SI seconds, occasionally the last minute of a UTC day is adjusted to have 61 seconds. The extra second is called a leap second. It accounts for the grand total of the extra length (about 2 milliseconds each) of all the mean solar days since the previous leap second. The last minute of a UTC day is permitted to contain 59 seconds to cover the remote possibility of the Earth rotating faster, but that has not yet been necessary.</p>
</div>
<h3 id="sincronizacao-de-relogios">Sincronização de Relógios</h3>
<p>Dado o UTC, temos então uma referência de tempo adequada para uso em sistemas computacionais, colocamos nova pergunta:</p>
<ul>
<li>Se o relógio se distância da medida correta da passagem do tempo, é possível corrigir este distanciamento, sincronizando-o com uma fonte correta, da qual UTC é nossa melhor aproximação, para que todos percebam a mesma passagem do tempo?</li>
</ul>
<p>Embora a resposta seja negativa, no sentido de que não é possível alcançar sincronização perfeita, nada nos impede de fazer um melhor esforço e, neste sentido, também temos que nos perguntar qual a frequência de sincronização?</p>
<div class="admonition question">
<p class="admonition-title">Frequência de Sincronização</p>
<p>Como garantir que dois relógios com erro máximo igual a <span><span class="MathJax_Preview">\rho</span><script type="math/tex">\rho</script></span> não diferirão em mais que <span><span class="MathJax_Preview">\delta</span><script type="math/tex">\delta</script></span> unidades de tempo?</p>
</div>
<details class="answer"><summary>Resposta</summary><p>Sincronize pelo menos a cada <span><span class="MathJax_Preview">\frac{\delta}{2\rho}</span><script type="math/tex">\frac{\delta}{2\rho}</script></span> segundos.</p>
</details>
<p>E se tivermos muitos relógios a serem sincronizados, o problema é mais difícil?</p>
<div class="admonition question">
<p class="admonition-title">Frequência de Sincronização</p>
<p>Como garantir que dois relógios quaisquer, em um sistema com <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> relógios, todos com erro máximo igual a <span><span class="MathJax_Preview">\rho</span><script type="math/tex">\rho</script></span>, não diferirão em mais que <span><span class="MathJax_Preview">\delta</span><script type="math/tex">\delta</script></span> unidades de tempo?</p>
</div>
<details class="answer"><summary>Resposta</summary><p>Se todos sincronizarem com a mesma fonte, a cada <span><span class="MathJax_Preview">\frac{\delta}{2\rho}</span><script type="math/tex">\frac{\delta}{2\rho}</script></span> segundos, seja o nó n1 aquele com maior erro em relação à fonte e n2 aquele com maior erro em relação a n1. Como ambos tem um erro máximo de <span><span class="MathJax_Preview">\delta</span><script type="math/tex">\delta</script></span> em relação à fonte, o erro máximo entre os dois nós é <span><span class="MathJax_Preview">2\delta</span><script type="math/tex">2\delta</script></span>. Como este erro é o dobro do desejado, basta dobrar a frequência de sincronização para cortar o erro pela metade.</p>
</details>
<p>Vejamos um exemplo:</p>
<ul>
<li><span><span class="MathJax_Preview">\rho = 0,1</span><script type="math/tex">\rho = 0,1</script></span></li>
<li><span><span class="MathJax_Preview">\delta</span><script type="math/tex">\delta</script></span> = 1s</li>
<li>Após 10s, um nó com estas características se dessincronizaria em, no máximo, 1s em relação ao UTC. </li>
<li>Como cada nó poderia estar errando em "direções"  diferentes, após 5s, um nó poderia se adiantar em 0,5s enquanto o outro se atrasa pela mesma quantidade de tempo, somando 1s de diferença. Logo, eles tem que se sincronizar a cada 5s, i.e, <span><span class="MathJax_Preview">\frac{\delta}{2\rho} = \frac{1s}{2 \times 0,1} = \frac{1s}{0,2} = 5s</span><script type="math/tex">\frac{\delta}{2\rho} = \frac{1s}{2 \times 0,1} = \frac{1s}{0,2} = 5s</script></span></li>
</ul>
<p>Como última parada antes de começarmos a falar sobre a sincronização em si, devemos estabelecer alguns cuidados a serem tomados no processo.</p>
<ul>
<li>Nunca voltar no tempo - isso poderia levar a um dado ter data de edição anterior a data de criação.</li>
<li>Ajustes graduais -  acelere ou desacelere o relógio (em software)<ul>
<li>Diminua/Aumente frequência de interrupção para atrasar/adiantar relógio</li>
<li>Diminua/Aumente incremento com cada interrupção</li>
</ul>
</li>
<li>Ajustes periódicos para fazer curvas convergirem.</li>
<li>Correção após dormir será mais drástica</li>
</ul>
<p>Agora que você já tem uma fonte confiável de tempo, o UTC, e sabe com que frequência sincronizar os relógios, só nos falta fazer a sincronização. 
Contudo, falta ainda definir o protocolo pelo qual a sincronização é feita e exatamente com quem, uma vez que simpleste UTC é muito genérico. 
Comecemos com vetor "próximo" do UTC, os relógios atômicos em satélites GPS.</p>
<h4 id="global-positioning-system">Global Positioning System</h4>
<p>Receptores GPS, com seus relógios sincronizados com os dos satélites, que difundem regularmente sua posição e o instante em que a difusão é feita, determinam sua posição relativa aos satélites, em uma técnica conhecida como trilateração, que consiste em determinar a distância do receptor em termos dos eixos <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> e <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span> em relação a cada um dos satélites. </p>
<p>Em outras palavras, baseado na informação de um satélite, o receptor determina sua distância ao mesmo e, portanto, determina que está em uma esfera no entorno do satélite.
Combinando a informação de 2 satélites, a posição do receptor é limitada a uma circunferência, isto é, a interseção de duas esferas. 
Com um terceiro satélite, a posição é reduzida a dois pontos, a interseção de uma esfera e uma circunferência, sendo um no espaço e que pode ser facilmente descartado. </p>
<p><img alt="Funcionamento de GPS" src="https://gisgeography.com/wp-content/uploads/2016/11/GPS-Trilateration-Feature-678x322.png" /></p>
<p>Contudo, para que funcione, relógios dos satélites e receptores precisam estar sincronizados para que o cálculo da distância possa ser feito, mas sincronizar os relógios é exatamente o problema que estamos tentando resolver. Para contornar esta restrição, usa-se um quarto satélite, para determinar a distância no "eixo temporal".</p>
<p>Assim, temos uma receita simples para sincronização de relógios com UTC:</p>
<ul>
<li>Coloque um receptor GPS em cada nó do seu sistema</li>
<li>Tenha erro de 0,1ns a 1ms do UTC</li>
</ul>
<p>Apesar da queda dos preços dos receptores, colocar um GPS em cada dispositivo pode ser custoso demais. 
Em vez disso, podemos usar um recurso amplamente disponível, redes de computadores, e sincronizar com outra máquina, que fez o investimento necessário para manter o erro baixo.
Para estes computadores "de segundo escalão", a receita então é:</p>
<ul>
<li>Pergunte que horas são.</li>
<li>Use a resposta para ajustar o relógio local.</li>
<li>Considere o erro introduzido pela latência variável da rede.</li>
</ul>
<p>Esta receita básica pode ser ajustada de diversas formas.</p>
<h4 id="algoritmo-de-cristian">Algoritmo de Cristian</h4>
<p>Assumindo que o relógio da máquina se sincronizando, <span><span class="MathJax_Preview">M_1</span><script type="math/tex">M_1</script></span>, é bom o suficiente para medir a passagem de tempo em períodos curtos, mesmo que tenha uma <em>drift</em> rate considerável em períodos mais longos, execute o seguinte protocolo para se sincronizar com <span><span class="MathJax_Preview">M_2</span><script type="math/tex">M_2</script></span>.</p>
<ul>
<li><span><span class="MathJax_Preview">M_1</span><script type="math/tex">M_1</script></span> pergunta "que horas são?" - <span><span class="MathJax_Preview">t_0</span><script type="math/tex">t_0</script></span></li>
<li><span><span class="MathJax_Preview">M_2</span><script type="math/tex">M_2</script></span> recebe pergunta - <span><span class="MathJax_Preview">t_1</span><script type="math/tex">t_1</script></span></li>
<li><span><span class="MathJax_Preview">M_2</span><script type="math/tex">M_2</script></span> anota o valor do relógio - <span><span class="MathJax_Preview">t_s</span><script type="math/tex">t_s</script></span></li>
<li><span><span class="MathJax_Preview">M_2</span><script type="math/tex">M_2</script></span> envia resposta - <span><span class="MathJax_Preview">t_2</span><script type="math/tex">t_2</script></span></li>
<li>
<p><span><span class="MathJax_Preview">M_1</span><script type="math/tex">M_1</script></span> recebe resposta - <span><span class="MathJax_Preview">t_3</span><script type="math/tex">t_3</script></span></p>
</li>
<li>
<p>Assuma <span><span class="MathJax_Preview">t_1 = t_s = t_2</span><script type="math/tex">t_1 = t_s = t_2</script></span></p>
</li>
<li>
<p>Assuma <span><span class="MathJax_Preview">\frac{t_3-t_0}{2}</span><script type="math/tex">\frac{t_3-t_0}{2}</script></span> como o tempo de transmissão da resposta (média da ida e da volta)</p>
</li>
<li><span><span class="MathJax_Preview">M_1</span><script type="math/tex">M_1</script></span> ajusta relógio para <span><span class="MathJax_Preview">t_c = t_s + \frac{t_3-t_0}{2}</span><script type="math/tex">t_c = t_s + \frac{t_3-t_0}{2}</script></span></li>
</ul>
<p>Mas e a aproximação <span><span class="MathJax_Preview">\frac{t_3-t_0}{2}</span><script type="math/tex">\frac{t_3-t_0}{2}</script></span>, é boa?
Podemos estimar o erro que ela introduz na sincronização, caso as mensagens tenham tempos de ida e volta assimétricos. Apesar das diferenças no tempo de ida e volta, existe um <strong>tempo mínimo</strong> para o tráfego em cada um dos sentidos, <span><span class="MathJax_Preview">T_{min}</span><script type="math/tex">T_{min}</script></span>.
A figura a seguir demonstra o erro desta técnica</p>
<p><img alt="Erro do algoritmo de Christian" src="images/cristianerror.png" /></p>
<p><a href="https://www.cs.rutgers.edu/~pxk/417/notes/content/05-clock-synchronization-slides.pdf">Fonte</a></p>
<p>Observe que há dois casos extremos de erro na estimativa.
No primeiro caso, dado um tempo de ida + volta igual a <span><span class="MathJax_Preview">T_1 - T_0</span><script type="math/tex">T_1 - T_0</script></span>, na figura, a mensagem de ida trafega no tempo mínimo e a volta lentamente. Neste caso, a estimativa <span><span class="MathJax_Preview">\frac{t_3-t_0}{2}</span><script type="math/tex">\frac{t_3-t_0}{2}</script></span> é menor que o tempo de volta real.
No segundo caso, a mensagem de ida trafega lentamente e a de volta no tempo mínimo, levando <span><span class="MathJax_Preview">\frac{t_3-t_0}{2}</span><script type="math/tex">\frac{t_3-t_0}{2}</script></span> a ser maior que tempo de transmissão real da mensagem.
O erro, contudo, está limitado à faixa amarela no desenho, que tem duração <span><span class="MathJax_Preview">T_1 - T_0 - 2T_{min}</span><script type="math/tex">T_1 - T_0 - 2T_{min}</script></span>. 
O erro então varia de mais ou menos metade deste valor. </p>
<h4 id="algoritmo-de-berkeley">Algoritmo de Berkeley</h4>
<p>Enquanto o algoritmo de Cristian permite sincronizar um nó com uma fonte, outro algoritmo, de Berkeley, permite sincronizar múltiplos nós uns com os outros. Este algoritmo assume o que não há uma "fonte da verdade" do tempo, mas sim a necessidade de que todos os processos convirjam para um mesmo valor do relógio. É como nos filmes de espião em que os relógios são sincronizados; pouco importa se a bomba explodirá 10:57 ou 10:59, desde que todos concordem quando isso vai acontecer. Isso é o que chamamos de <strong>sincronização interna</strong> em vez de externa, como provido pelo algoritmo de Cristian.</p>
<p>O algoritmo de Berkeley requer que todo nó execute um processo de sincronização, um "daemon", e separa seus papéis em dois tipos, <strong>primário</strong> e <strong>secundário</strong>.
O papel do primário pode ser rotacionado entre os vários processos, sem perdas para sua execução. O algoritmo então é executacomo se segue:</p>
<ul>
<li>Primário pergunta "que horas são" para cada secundário (mensages 1,2,3 e 4)</li>
<li>Secundário responde com valor atual do relógio (mensagens 5,6,7 e 8)</li>
<li>Primário ajusta as respostas de acordo com o algoritmo de Cristian, para minimizar erros.</li>
<li>Primário computa média dos valores recebidos, ignorando <em>outliers</em> (como o da mensagem 8).</li>
<li>Primário envia <strong>ajustes</strong> para secundários (mensagens 8,9,10 e 11)</li>
<li>Secundário executa ajuste sugerido pelo primário.</li>
</ul>
<div class="mermaid">
sequenceDiagram
    autonumber
    note over Primário: 10:00
    note over Secundário1: 10:06
    note over Secundário2: 10:15
    note over Secundário3: 23:18
    par Pergunta
      Primário-&gt;&gt;Primário: Que horas são?
    and
      Primário-&gt;&gt;Secundário1: Que horas são?
    and
      Primário-&gt;&gt;Secundário2: Que horas são?
    and
      Primário-&gt;&gt;Secundário3: Que horas são?
    end

    par Resposta
      Primário-&gt;&gt;Primário: 10:00
    and
      Secundário1-&gt;&gt;Primário: 10:06
    and
      Secundário2-&gt;&gt;Primário: 10:15
    and
      rect rgb(255, 0, 0)
         Secundário3-&gt;&gt;Primário: 23:18
      end
    end

    par Ajuste
      Primário-&gt;&gt;Primário: 10:07
    and
      Primário-&gt;&gt;Secundário1: 10:07
    and
      Primário-&gt;&gt;Secundário2: 10:07
    and
      Primário-&gt;&gt;Secundário3: 10:07
    end
</div>
<p>Embora interessantes, estes algoritmos não são normalmente usados, pelo menos não em sua forma "pura", em sistemas computacionais. Em vez deles, usamos o Network Time Protocol (NTP).</p>
<h4 id="network-time-protocol">Network Time Protocol.</h4>
<p>O NTP foi especificado originalmente na RFC 1305<sup id="fnref:rfc1305"><a class="footnote-ref" href="#fn:rfc1305">5</a></sup> e estendido pelas RFCRFC 5905-5908<sup id="fnref:rfc5905-5908"><a class="footnote-ref" href="#fn:rfc5905-5908">6</a></sup> essencialmente para suportar IPv6 e reduzir o erro de sincronização para até 10<span><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span>s.</p>
<p>Os diversos componentes do NTP são organizados em camadas, ou <em>estrata</em>, de forma que a informação do tempo flui da camada 0 (<em>stratum 0</em>) até a camada 15 (<em>stratum</em> 15).
Os componentes não estão presos a camadas, que podem ser alteradas a medida que falhas acontecem e são dedicadas, e novos caminhos são encontrados usando-se o algoritmo de árvore geradora mínima Bellman-Ford, além de caminhos redundantes que conferem propriedades de <strong>tolerância a falhas</strong> à topologia.</p>
<p><img alt="Network Time Protocol" src="images/ntp.png" /><sup id="fnref:ntpfigure"><a class="footnote-ref" href="#fn:ntpfigure">4</a></sup></p>
<p>Esta <strong>organização hierárquica</strong> leva a cada camada garantir um nível de sincronização diferente e permite <strong>escalar o uso do protocolo para níveis globais</strong>, usando a <strong>Internet como meio</strong>.</p>
<ul>
<li>Stratum 0: relógios atômicos/receptores GPS</li>
<li>Stratum 1: ms to stratum 0</li>
<li>Stratum 2: contata múltiplos stratum 1 e pares</li>
<li>Strata 3...15</li>
<li>Stratum 16: dessincronizado</li>
</ul>
<p>Toda a comunicação entre nós pode ser <strong>autenticada</strong>, garantindo que a sincronização não seja facilmente manipulada e erros são minimizados pela coleta e uso de estatísticas de latência de comunicação, para evitar desvios quando fontes se tornam problemáticas.</p>
<p>NTP tem múltiplas formas de execução, adequadas para diferentes ambientes.</p>
<ul>
<li>Modo multicast: propaga tempo em rede local</li>
<li>RPC: algoritmo de Cristian</li>
<li>Simétrico: parecido com Berkeley</li>
</ul>
<p>Na prática, boa parte dos dispositivos usa uma versão simplificada do NTP, o SNTP (<strong><em>Simple Network Time Protocol</em></strong>), adequada aos nós nas <strong>folhas da hierarquia</strong>. 
O SNTP é essencialmente o algoritmo de Cristian:</p>
<ul>
<li><span><span class="MathJax_Preview">\delta = (t_4-t_1)-(t_2-t_3)</span><script type="math/tex">\delta = (t_4-t_1)-(t_2-t_3)</script></span></li>
<li><span><span class="MathJax_Preview">t = \frac{(t_2-t_1)+(t3-t_4)}{2}</span><script type="math/tex">t = \frac{(t_2-t_1)+(t3-t_4)}{2}</script></span></li>
<li><span><span class="MathJax_Preview">t_c = t_4+t</span><script type="math/tex">t_c = t_4+t</script></span></li>
</ul>
<p>Por exemplo,</p>
<ul>
<li><span><span class="MathJax_Preview">t_1 = 1100, t_2 = 800, t_3=850, t_4=1200</span><script type="math/tex">t_1 = 1100, t_2 = 800, t_3=850, t_4=1200</script></span></li>
<li><span><span class="MathJax_Preview">t = ((800-1100)+(850-1200))/2 = (-300 -350)/ = -325</span><script type="math/tex">t = ((800-1100)+(850-1200))/2 = (-300 -350)/ = -325</script></span></li>
<li><span><span class="MathJax_Preview">t_c = 1200-325 = 875</span><script type="math/tex">t_c = 1200-325 = 875</script></span></li>
</ul>
<p>O Comitê Gestor da Internet, <a href="https://cgi.br/">CGI</a>, mantem uma excelente página sobre o NTP, com mais detalhes do que apresentado aqui, em <a href="https://ntp.br/ntp.php">NTP.br</a>.</p>
<h4 id="ptp-precision-time-protocol">PTP - Precision Time Protocol</h4>
<p>Mesmo com melhoria do protocolo e baratemento de dispositivos GPS, há ainda a necessidade de sincronização sub-microssegundo e barata. O <strong><em>Precision Time Protocol</em></strong>, PTP, especificação IEEE 1588<sup id="fnref:ieee1588"><a class="footnote-ref" href="#fn:ieee1588">7</a></sup> tenta cobrir este nicho.</p>
<p>Se escrutinizarmos o PTP, veremos que o protocolo em si não difere muito do NTP. Contudo, o PTP usa interfaces de rede especilizadas para fazer o <em>timestamping</em> dos eventos do protocolo, conseguindo remover a latência nos dispositivos processando as mensagens e reduzindo o erro do protocolo até sub <span><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span> (versus ordem de <span><span class="MathJax_Preview">ms</span><script type="math/tex">ms</script></span> no NTP).
Mais detalhes sobre o protocolo estão fora do escopo deste documento, mas podem ser facilmente encontrados nos links dados.</p>
<h3 id="usos-de-relogios-sincronizados">Usos de relógios sincronizados</h3>
<p>Assumindo que tenhamos sincronizado os relógios de um sistema computacional, o que podemos fazer agora? Uma série de problemas interessantes que podem ser resolvidos,
como <strong>autenticação</strong>, <strong>terminação de transações</strong>, <strong>alocação de <em>leases</em></strong> e diversos outros exemplos<sup id="fnref:liskov"><a class="footnote-ref" href="#fn:liskov">8</a></sup>.</p>
<p>Um exemplo interessante é a ordenação de eventos em um banco de dados.
Para entender este problema, considere um cenário com um Sistema Bancário replicado, isto é, com várias cópias.
No exemplo, nos focamos em duas cópias em lados opostos de uma rede de larga escala.
Clientes disparam operações como saques, depósitos e transferências, por meio de mensagens para as duas cópias. 
Mensagens para a cópia próxima do cliente (em verde) são entregues rapidamente, enquanto mensagens para a cópia distante (em vermelho), demoram mais para ser entregues.</p>
<p><img alt="Sistema Bancário Replicado" src="drawings/dist_trans.drawio-0.svg" /></p>
<p>Imagine que o usuário U1 envie o comando C1 "atualizar saldo da conta para USD 10<sup id="fnref:usd"><a class="footnote-ref" href="#fn:usd">9</a></sup>" e que o usuário U2 envie o comando C2 "atualizar saldo da conta para USD 20".
Se os comandos chegam primeiro para a réplica mais próxima e são executados na ordem em que chegam, ao final da execução a réplica R1 terá executado C1 seguido de C2, tendo saldo da conta como USD 20, enquanto R2 terá executado C2 seguido de C1 e terá como saldo na conta USD 10.
O problema está na ordem de execução das operações.</p>
<p>Assuma que relógios estão <strong>perfeitamente</strong> sincronizados e que toda mensagem/update carrega consigo o <em>timestamp</em> de quando foi enviada.
E se as réplicas processarem mensagens na ordem que foram enviadas, como identificado pelos seus <em>timestamps</em>?<sup id="fnref:tiebreak"><a class="footnote-ref" href="#fn:tiebreak">10</a></sup>
Assim, se C1 foi enviado antes de C2, C1 tem um <em>timestamp</em> menor que C2 e será executada primeiro em ambas as réplicas, o que resolve nosso problema, correto?
Parcialmente, pois ainda temos o problema de identificar que nenhuma outra mensagem ainda por ser entregue foi enviada antes. 
Para isto, precisamos estender o modelo e assumir que o tempo de propagação máximo de uma mensagem, <span><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span>, é finito.
Assim, ao  receber um comando com timestamp <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>, uma réplica espera até <span><span class="MathJax_Preview">t + \tau</span><script type="math/tex">t + \tau</script></span> antes de executá-lo, pois qualquer comando com <em>timestamp</em> <span><span class="MathJax_Preview">t' &lt; t</span><script type="math/tex">t' < t</script></span> deve ter sido entregue até <span><span class="MathJax_Preview">t+\tau</span><script type="math/tex">t+\tau</script></span>.</p>
<p><img alt="Ordenação" src="images/ordenacao1.png" /></p>
<p>Implementar este protocolo é muito simples:</p>
<div class="admonition example">
<p class="admonition-title">Ordenação de Mensagens por Timestamp</p>
</div>
<ul>
<li>Quando enviar uma mensagem, aumente-a com o valor atual do relógio.</li>
<li>Quando receber uma mensagem, coloque-a em uma fila ordenada por <em>timestamp</em>.</li>
<li>Quando o relógio marcar um tempo maior que <span><span class="MathJax_Preview">t + \tau</span><script type="math/tex">t + \tau</script></span>, onde <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> é o timestamp da mensagem na cabeça da fila, retire a mensagem da cabeça e da fila e execute o comando correspondente.</li>
</ul>
<p>Embora correto, este protocolo, ou melhor, o modelo, não leva em consideração a dessincronização inerente dos relógios em um sistema distribuído. 
Como fazê-lo, supondo uma divergência máxima de <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span> entre quaisquer dois relógios, algo que pode ser arranjado, como visto antes, sincronizando-se os relógios a cada <span><span class="MathJax_Preview">\frac{\Delta}{2*\rho}</span><script type="math/tex">\frac{\Delta}{2*\rho}</script></span>.</p>
<p>Se <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span> é a diferença máxima entre relógios, então se uma mensagem é enviada no instante <span><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>, então até <span><span class="MathJax_Preview">\Delta +t</span><script type="math/tex">\Delta +t</script></span>, outro processo, atrasado em relação ao primeiro, poderá enviar uma mensagem com timestamp <span><span class="MathJax_Preview">t' &lt; t</span><script type="math/tex">t' < t</script></span>. 
Tal mensagem pode demorar até <span><span class="MathJax_Preview">\tau</span><script type="math/tex">\tau</script></span> para ser entregue à réplica, ou seja, no instante <span><span class="MathJax_Preview">t + \tau + \Delta</span><script type="math/tex">t + \tau + \Delta</script></span>, do ponto de vista do primeiro cliente.</p>
<p>Se a réplica estiver sincronizada com cliente, então se esperar até <span><span class="MathJax_Preview">t + \tau + \Delta</span><script type="math/tex">t + \tau + \Delta</script></span> para executar o comando, o fará de forma segura. 
Se estiver atrasada em relação ao primeiro cliente, então acabará por esperar além do necessário, mas sem violar a corretude do sistema.</p>
<p>Finalmente, se a réplica estiver adiantada em relação ao primeiro cliente, então seu relógio alcançará <span><span class="MathJax_Preview">t + \tau + \Delta</span><script type="math/tex">t + \tau + \Delta</script></span> antes do relógio do primeiro cliente, mas isso não é um problema. Isto porquê, o último instante em que o cliente 2 poderá enviar uma mensagem com timestamp <span><span class="MathJax_Preview">t' &lt; t</span><script type="math/tex">t' < t</script></span> é o instante em que o relógio da réplica marcar <span><span class="MathJax_Preview">t + \Delta</span><script type="math/tex">t + \Delta</script></span>, e portanto deverá também ser recebido até que o mesmo relógio marque <span><span class="MathJax_Preview">t + \tau + \Delta</span><script type="math/tex">t + \tau + \Delta</script></span>. </p>
<p><img alt="Ordenação" src="images/ordenacao2.png" /></p>
<p>O mesmo raciocínio pode ser usado para definir um protocolo de acesso recursos para os quais <em>leases</em> são distribuídos, onde um <em>lease</em>  é uma permissão de acesso durante uma janela de tempo, emitida por um coordenador (possivelmente eleito usando os algoritmos vistos anteriormente), e <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span> é o máximo de dessincronismo entre os relógios. 
O seguinte protocolo resolve este problema:</p>
<div class="admonition example">
<p class="admonition-title">Alocação de Lease</p>
<p>Ao receber um <em>lease</em> para a janela de tempo <span><span class="MathJax_Preview">t_1</span><script type="math/tex">t_1</script></span> a <span><span class="MathJax_Preview">t_2</span><script type="math/tex">t_2</script></span></p>
<ul>
<li>espera até <span><span class="MathJax_Preview">t_1 + \Delta</span><script type="math/tex">t_1 + \Delta</script></span></li>
<li>usa o recurso até <span><span class="MathJax_Preview">t_2</span><script type="math/tex">t_2</script></span>.</li>
</ul>
</div>
<p>Se relógio estiver adiantado em relação ao cliente anterior, vai achar que é <span><span class="MathJax_Preview">t_1+\Delta</span><script type="math/tex">t_1+\Delta</script></span> enquanto o anterior acha que é <span><span class="MathJax_Preview">t_1</span><script type="math/tex">t_1</script></span>; exclusão mútua garantida.
Se relógio estiver atrasado em relação ao cliente anterior, vai achar que é <span><span class="MathJax_Preview">t_1 - \Delta</span><script type="math/tex">t_1 - \Delta</script></span>, e continua esperando, enquanto ele acha que já é <span><span class="MathJax_Preview">t_1</span><script type="math/tex">t_1</script></span> e para de usar; exclusão mútua garantida.
Recurso fica ocioso por <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span>, em média, a cada lease. </p>
<p>Devido ao alto custo de se manter o recurso não utilizado, <span><span class="MathJax_Preview">\Delta</span><script type="math/tex">\Delta</script></span> deve ser feito tão pequeno quanto possível. 
Leia <a href="https://cloud.google.com/spanner/docs/true-time-external-consistency">Google True Time e Spanner</a> para ver como o Google consegue manter a diferença em sub milisegundos, usando relógios atômicos dentro de seus datacenters e um API para geração de timestamps.</p>
<details class="todo"><summary>Todo</summary><ul>
<li><a href="https://cloud.google.com/spanner/docs/true-time-external-consistency">Google TrueTime</a></li>
</ul>
</details>
<p>Nas soluções anteriores, um nó precisa esperar por muito tempo antes de usar um recurso. 
E se ele aprendesse antes que os outros nós não farão requisições? 
Que não haverão sobreposições de requisições? 
E se houvesse um relógio que avançasse não com o tempo, mas com eventos interessantes do sistema?
Esta é a ideia dos <strong>relógios lógicos</strong>.</p>
<h2 id="tempo-logico">Tempo Lógico</h2>
<p>A ideia por trás do "tempo lógico" é de o que importa são eventos e não a passagem do tempo, uma vez que tempo é relativo aos processos <sup id="fnref:tempologico"><a class="footnote-ref" href="#fn:tempologico">11</a></sup>.
Assim, surgem os relógios lógicos, que ``ticam'' quando um evento importante acontece.</p>
<p>Para chegarmos aos relógios lógicos, precisamos primeiro entender a relação <strong><em>Happened-Before</em></strong>, proposta por Leslie Lamport<sup id="fnref:tcoeds"><a class="footnote-ref" href="#fn:tcoeds">12</a></sup> e que lhe rendeu um <a href="https://amturing.acm.org/">Prêmio Turing</a> em <a href="https://www.microsoft.com/en-us/research/blog/leslie-lamport-receives-turing-award/">2014</a>.
Hoje é comum usar a relação <em>happened-before</em> e o vocabulário associado para falar sobre ordem de eventos em um sistema computacional, em especial um distribuído.</p>
<h3 id="happened-before">Happened-Before</h3>
<p>A relação <em>happened-before</em> captura a <strong>causalidade</strong> entre eventos.
Isto é, se um evento <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> <strong>aconteceu-antes</strong> de um evento <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>, então <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> potencialmente causou <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>.
Também podemos dizer que <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> precede <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> em uma ordem causal.</p>
<p>O evento <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> aconteceu-antes <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>, notado como <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span>, se uma das três condições seguintes é válida:</p>
<div class="admonition note">
<p class="admonition-title">Happened-Before</p>
<ul>
<li>Se <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> e <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> são eventos em um mesmo processo (ou <em>thread</em>) e <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> foi executado antes de <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>.</li>
<li>Se <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> e <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> são eventos de processos distintos e <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> é o envio de uma mensagem e <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> a sua recepção.</li>
<li>Se há transitividade, isto é, se existe um evento <span><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span> tal que <span><span class="MathJax_Preview">a \rightarrow c</span><script type="math/tex">a \rightarrow c</script></span> e <span><span class="MathJax_Preview">c \rightarrow b</span><script type="math/tex">c \rightarrow b</script></span>.</li>
</ul>
</div>
<details class="todo"><summary>TODO</summary><p>Imagem somente com os eventos, sem o valor do relógio.</p>
</details>
<p><img alt="LC - Primeira tentativa" src="images/lc_cont.png" /></p>
<p>Note que se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> é falso e <span><span class="MathJax_Preview">b \rightarrow a</span><script type="math/tex">b \rightarrow a</script></span> é falso, então <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> e <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> são <strong>concorrentes</strong>, e que ser concorrente não quer dizer que aconteceram exatamente no mesmo instante, do ponto de vista de um observador externo.
Ser concorrente quer dizer que um evento <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> não podem ter sido a causa do evento <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>, dado que os efeitos de <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> não poderiam ser conhecidos pelo processo onde <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> ocorreu, quando <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> ocorreu.
O cone de luz na figura seguinte mostra esta relação entre eventos.</p>
<p><img alt="Light-cone" src="drawings/light_cone.drawio-0.svg" /></p>
<p>Se capturarmos a causalidade de eventos, podemos usar esta informação para ordenar o se processamento, de forma a fazer sentido.
Considere o seguinte exemplo, em que o primeiro usuário de um serviço de emails recebe primeiro a resposta da mensagem A, R:A, para somente depois receber A.
Para que a troca de mensagens faça sentido, o usuário posterga a leitura de R:A até depois de ter lido A.</p>
<p><img alt="Inversão causal" src="drawings/multicast.drawio-0.svg" /></p>
<p>Observe que em nenhum momento a informação sobre <strong>quando</strong> as mensagens foram enviadas foi necessária, apenas a <strong>ordem</strong> das mesmas.
Relógios lógicos permitem que sistemas capturem a relação de causalidade entre eventos e implementem esquemas como o apenas descrito, para coordenar as ações dos processos em sistemas distribuídos.</p>
<h3 id="relogios-logicos">Relógios lógicos</h3>
<p>Para que computadores possam usar a causalidade, precisamos capturar a relação de acontecer antes em um sistema.
Lamport propôs uma tal forma, que denominou <strong>relógio lógico</strong>, mas que hoje é conhecido universalmente como <strong>relógio de Lamport</strong>.
Estes relógios permitem associar um <em>timestamp</em> a eventos de forma a se garantir a seguinte propriedade:</p>
<ul>
<li>seja <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> um evento</li>
<li>seja <span><span class="MathJax_Preview">C(e)</span><script type="math/tex">C(e)</script></span> o valor do relógio lógico quando associado a <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span></li>
<li>se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> então <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span></li>
</ul>
<p>Mas como definir a função <span><span class="MathJax_Preview">C</span><script type="math/tex">C</script></span>?
Experimentemos a seguinte definição:</p>
<div class="admonition example">
<p class="admonition-title">Quase Relógio de Lamport</p>
<ul>
<li>Seja <span><span class="MathJax_Preview">c_p</span><script type="math/tex">c_p</script></span> um contador em <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> com valor inicialmente igual a 0.</li>
<li><span><span class="MathJax_Preview">C(e) = ++c_p</span><script type="math/tex">C(e) = ++c_p</script></span> no momento em que <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> ocorreu.</li>
<li>Usamos como <span><span class="MathJax_Preview">&lt;</span><script type="math/tex"><</script></span> a relação normal de inteiros.</li>
</ul>
</div>
<p>Observe que não há <strong>fonte da verdade</strong> em termos de tempo lógico, já que <strong>cada processo mantém seu próprio relógio</strong> que pode ser relacionado com relógios de outros processos.
Veja um exemplo desta definição em ação.</p>
<p><img alt="LC - Primeira tentativa" src="images/lc_cont.png" /></p>
<p>É verdade neste cenário que se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> então <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span>?<br />
Observe com atenção os eventos <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> e <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>, pois para estes, a regra não é respeitada.</p>
<h4 id="relogio-de-lamport">Relógio de Lamport</h4>
<p>Para que a regra <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> então <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span> seja válida, precisamos modificar a tentativa anterior para que, na recepção de uma mensagem, os contadores sejam atualizados para que sejam maiores tanto que os relógios dos eventos locais quanto dos eventos que antecederam o envio da mensagem sendo recebida.</p>
<div class="admonition example">
<p class="admonition-title">Relógio de Lamport</p>
<ul>
<li>Seja <span><span class="MathJax_Preview">c_p</span><script type="math/tex">c_p</script></span> um contador em <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> com valor inicialmente igual a 0.</li>
<li>Se o evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é uma operação local<ul>
<li><span><span class="MathJax_Preview">c_p \gets c_p + 1</span><script type="math/tex">c_p \gets c_p + 1</script></span></li>
<li><span><span class="MathJax_Preview">C(e) \gets c_p</span><script type="math/tex">C(e) \gets c_p</script></span></li>
</ul>
</li>
<li>Se o evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é o envio de uma mensagem<ul>
<li><span><span class="MathJax_Preview">c_p \gets c_p + 1</span><script type="math/tex">c_p \gets c_p + 1</script></span></li>
<li><span><span class="MathJax_Preview">C(e) \gets c_p</span><script type="math/tex">C(e) \gets c_p</script></span></li>
<li><span><span class="MathJax_Preview">C(e)</span><script type="math/tex">C(e)</script></span> é enviado com a mensagem como seu timestamp.</li>
</ul>
</li>
<li>Se o evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é a recepção de uma mensagem com timestamp <span><span class="MathJax_Preview">ts</span><script type="math/tex">ts</script></span><ul>
<li><span><span class="MathJax_Preview">c_p \gets max(c_e,ts)+1</span><script type="math/tex">c_p \gets max(c_e,ts)+1</script></span>.</li>
<li><span><span class="MathJax_Preview">C(e) \gets c_p</span><script type="math/tex">C(e) \gets c_p</script></span></li>
</ul>
</li>
</ul>
</div>
<p>Com este ajuste, temos os <strong>Relógios de Lamport</strong>.</p>
<p><img alt="LC - Primeira tentativa" src="images/lc_lamport.png" /></p>
<p>Neste caso, temos que para quaisquer eventos <span><span class="MathJax_Preview">a,b</span><script type="math/tex">a,b</script></span>,  se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> então <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span>.</p>
<details class="todo"><summary>Todo</summary><p>Exemplo em que não é bom o suficiente.</p>
</details>
<p>Se <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span> então <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span>. Contudo, a volta não é verdade, isto é, se <span><span class="MathJax_Preview">C(a) &lt; C(b)</span><script type="math/tex">C(a) < C(b)</script></span> então <span><span class="MathJax_Preview">a \rightarrow b</span><script type="math/tex">a \rightarrow b</script></span>.
Esta propriedade é interessante na ordenação de eventos, pois evita que eventos concorrentes sejam ordenados.
Entram os relógios vetoriais.</p>
<h4 id="relogio-vetorial">Relógio Vetorial</h4>
<p><strong>Relógios vetoriais</strong> são relógios lógicos em que cada processo mantém não apenas um contador dos seus eventos locais, mas também sua visão dos contadores dos outros processos.
Estas visões são atualizadas a cada recepção de mensagem, de acordo com a seguinte especificação, onde assume-se que <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> processos fazem parte do sistema.</p>
<div class="admonition example">
<p class="admonition-title">Relógio Vetorial</p>
<p>Considerando o ponto de vista do processo <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span></p>
<ul>
<li>Seja <span><span class="MathJax_Preview">c_p[i], 1 \leq i \leq n</span><script type="math/tex">c_p[i], 1 \leq i \leq n</script></span> inicialmente igual a 0</li>
<li>Seja um evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span><ul>
<li>Se <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é uma operação local<ul>
<li><span><span class="MathJax_Preview">c_p[p] \gets c_p[p] + 1</span><script type="math/tex">c_p[p] \gets c_p[p] + 1</script></span></li>
<li><span><span class="MathJax_Preview">V(e) \gets c_p</span><script type="math/tex">V(e) \gets c_p</script></span></li>
</ul>
</li>
<li>Se <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é o envio de uma mensagem<ul>
<li><span><span class="MathJax_Preview">c_p[p] \gets c_p[p] + 1</span><script type="math/tex">c_p[p] \gets c_p[p] + 1</script></span></li>
<li><span><span class="MathJax_Preview">V(e) \gets c_p</span><script type="math/tex">V(e) \gets c_p</script></span></li>
<li><span><span class="MathJax_Preview">V(e)</span><script type="math/tex">V(e)</script></span> é enviado com a mensagem como seu timestamp.</li>
</ul>
</li>
<li>Se <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é a recepção de uma mensagem com timestamp <span><span class="MathJax_Preview">ts</span><script type="math/tex">ts</script></span> de <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>, então<ul>
<li><span><span class="MathJax_Preview">c_p[i] \gets max(c_p[i], ts[i]), \forall i \neq p</span><script type="math/tex">c_p[i] \gets max(c_p[i], ts[i]), \forall i \neq p</script></span></li>
<li><span><span class="MathJax_Preview">c_p[p] \gets c_p[p] + 1</span><script type="math/tex">c_p[p] \gets c_p[p] + 1</script></span></li>
<li><span><span class="MathJax_Preview">V(e) \gets c_p</span><script type="math/tex">V(e) \gets c_p</script></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>Uma observação interessante a ser feita aqui é que embora o algoritmo pareça indicar que cada processo precisa saber quantos mais processos existem no sistema, isto não é verdade, pois pode-se assumir que para todo processo desconhecido <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>, <span><span class="MathJax_Preview">c_p[q] = 0</span><script type="math/tex">c_p[q] = 0</script></span>.</p>
<p>Como dito, este relógio lógico tem a propriedade <span><span class="MathJax_Preview">a \rightarrow b \iff V(a) &lt; V(b)</span><script type="math/tex">a \rightarrow b \iff V(a) < V(b)</script></span>, considerando-se a seguinte definição de <span><span class="MathJax_Preview">&lt;</span><script type="math/tex"><</script></span> para vetores:</p>
<div class="admonition note">
<p class="admonition-title">Comparação entre vetores</p>
<ul>
<li><span><span class="MathJax_Preview">v = v' \iff v[i] = v'[i], 1 \leq i \leq n</span><script type="math/tex">v = v' \iff v[i] = v'[i], 1 \leq i \leq n</script></span></li>
<li><span><span class="MathJax_Preview">v \leq v' \iff v[i] \leq v'[i], 1 \leq i \leq n</span><script type="math/tex">v \leq v' \iff v[i] \leq v'[i], 1 \leq i \leq n</script></span></li>
<li><span><span class="MathJax_Preview">v &lt; v' \iff v \leq v' \land v \neq V'</span><script type="math/tex">v < v' \iff v \leq v' \land v \neq V'</script></span></li>
</ul>
</div>
<p>Assim, sejam dois eventos <span><span class="MathJax_Preview">e \neq e'</span><script type="math/tex">e \neq e'</script></span>:</p>
<ul>
<li><span><span class="MathJax_Preview">e \rightarrow e' \iff V(e) &lt; V(e')</span><script type="math/tex">e \rightarrow e' \iff V(e) < V(e')</script></span></li>
<li>Se <span><span class="MathJax_Preview">V(e) \not &lt; V(e')</span><script type="math/tex">V(e) \not < V(e')</script></span> e <span><span class="MathJax_Preview">V(e') \not &lt; V(e)</span><script type="math/tex">V(e') \not < V(e)</script></span>, então <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> e <span><span class="MathJax_Preview">e'</span><script type="math/tex">e'</script></span> são concorrentes.</li>
</ul>
<p>Para entender melhor como esta definição funciona, considere a seguinte execução.
O que quer dizer <span><span class="MathJax_Preview">c_p[q] = k</span><script type="math/tex">c_p[q] = k</script></span>, ou tomando o evendo <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> como exemplo, o que quer dizer <span><span class="MathJax_Preview">c_{P_2}[1]=2</span><script type="math/tex">c_{P_2}[1]=2</script></span>?</p>
<p><img alt="Relógio Vetorial" src="images/lc_vc.png" /></p>
<p>Quer dizer que <span><span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script></span> está ciente de 2 eventos locais a <span><span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script></span>, assim com está ciente de 0 eventos em <span><span class="MathJax_Preview">P_3</span><script type="math/tex">P_3</script></span> e de que <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> é o segundo evento em <span><span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script></span>.
Logo, <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> pode ter sido causado por 2 eventos de <span><span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script></span>, 1 evento de <span><span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script></span> e 0 de <span><span class="MathJax_Preview">P_3</span><script type="math/tex">P_3</script></span>.</p>
<p>Agora compare os eventos <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> e <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>.
<span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> e <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> são concorrentes pois embora as posições 1 e 2 de <span><span class="MathJax_Preview">V(d)</span><script type="math/tex">V(d)</script></span> sejam maiores que em <span><span class="MathJax_Preview">V(e)</span><script type="math/tex">V(e)</script></span>, a posição 3 é menor.
Isso quer dizer que o nem <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> está ciente do evento <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> e nem <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span> está ciente do evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>, ou melhor, que um não pode ter causado o outro.</p>
<p>Esta abstração simples já é muito poderosa e, embora possa ser melhorada<sup id="fnref:matrix_clock"><a class="footnote-ref" href="#fn:matrix_clock">13</a></sup>, já é suficiente para se implementar outras abstrações interessantes, como será visto adiante.
Antes, é necessário mencionar mais um tipo de relógio lógico, os híbridos.</p>
<h4 id="relogios-hibridos">Relógios Híbridos</h4>
<p>A grande vantagem dos relógios lógicos sobre os físicos é de ignorar a passagem do tempo, só se importanto com a ordem de eventos.
Esta vantagem também é uma desvantagem quando eventos precisam ser associados a eventos externos ao sistema, por exemplo, durante uma sessão de depuração.
Suponha que após uma atualização de um sistema, você note um problema nos dados e, em depurando o problema, identifique o evento problemático nos <em>logs</em> do sistema, associado ao seu relógio lógico.
Como identificar se este evento problemático aconteceu antes ou depois da atualização?
<a href="http://muratbuffalo.blogspot.com.br/2014/07/hybrid-logical-clocks.html">Relógios híbridos</a> tentam resolver este problema combinando relógios físicos e lógicos em um.</p>
<p>No seguinte algoritmo, cada processo mantem um relógio físico e um lógico e sempre que um evento acontece, usa como novo valor do relógio lógico o máximo entre o valor anterior + 1, o valor do <em>timestamp</em> na mensagem sendo recebida + 1, se for o recebimento de uma mensagem, e o valor do relógio físico.
Isto é, se poucos eventos acontecerem, o valor do relógio lógico acompanhará o valor do físico.</p>
<div class="admonition example">
<p class="admonition-title">Relógio Híbrido Simples</p>
<p>Considerando o ponto de vista do processo <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span></p>
<ul>
<li><span><span class="MathJax_Preview">c_p.f</span><script type="math/tex">c_p.f</script></span> é o relógio físico de <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>, incrementado automaticamente</li>
<li><span><span class="MathJax_Preview">c_p.l</span><script type="math/tex">c_p.l</script></span> é o relógio lógico de <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>, inicialmente 0</li>
<li>Seja um evento <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span><ul>
<li>Se <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é uma operação local<ul>
<li><span><span class="MathJax_Preview">c_p.l \gets max(c_p.l + 1, c_p.f)</span><script type="math/tex">c_p.l \gets max(c_p.l + 1, c_p.f)</script></span></li>
<li><span><span class="MathJax_Preview">H(e) \gets c_p.l</span><script type="math/tex">H(e) \gets c_p.l</script></span></li>
</ul>
</li>
<li>Se <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é o envio de uma mensagem<ul>
<li><span><span class="MathJax_Preview">c_p.l \gets max(c_p.l + 1, c_p.f)</span><script type="math/tex">c_p.l \gets max(c_p.l + 1, c_p.f)</script></span></li>
<li><span><span class="MathJax_Preview">H(e) \gets c_p.l</span><script type="math/tex">H(e) \gets c_p.l</script></span></li>
<li><span><span class="MathJax_Preview">H(e)</span><script type="math/tex">H(e)</script></span> é enviado com a mensagem como seu timestamp.</li>
</ul>
</li>
<li>Se <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> é a recepção de uma mensagem com timestamp <span><span class="MathJax_Preview">ts</span><script type="math/tex">ts</script></span> de <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>, então<ul>
<li><span><span class="MathJax_Preview">c_p.l \gets max(c_p.l + 1, ts + 1, c_p.f)</span><script type="math/tex">c_p.l \gets max(c_p.l + 1, ts + 1, c_p.f)</script></span></li>
<li><span><span class="MathJax_Preview">V(e) = c_p.l</span><script type="math/tex">V(e) = c_p.l</script></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p><img alt="Relógio Híbrido Simples" src="drawings/hibrido.drawio-0.svg" /></p>
<p>Nesta versão do algoritmo, contudo, se muitos eventos acontecerem, o valor do relógio lógico pode ser incrementadado muito rapidamente, perdendo a relação com o relógio físico.
Em uma versão melhorada do algoritmo,<sup id="fnref:hlc"><a class="footnote-ref" href="#fn:hlc">14</a></sup> a distância entre os dois relógios é limitada, mantendo a propriedade que faz o relógios híbridos interessantes.<sup id="fnref:hlcerror"><a class="footnote-ref" href="#fn:hlcerror">15</a></sup></p>
<!--![Hibrid Logical Clock](images/lc_hybrid.png) - Onde se lê 3,13, leia-se 3,10,3.-->

<h3 id="comunicacao-em-grupo">Comunicação em Grupo</h3>
<p>Relógios lógicos podem e são usados diretamente em sistemas, por exemplo, para controlar versões no sistema de identidade da Microsoft, <a href="https://cdn.ttgtmedia.com/searchwin2000/downloads/pdfs/ImplementingtheAD202014.pdf">Active Directory</a>.
Outra forma de uso é como block de construção de outras abstrações, por exemplo, primitivas de comunicação em grupo, pelas quais um processo envia mensagens para um conjunto de processos.</p>
<ul>
<li>Difusão Totalmente Ordenada (<em>Total Order Multicast</em>):<ul>
<li>Difusão: mensagens são enviadas de 1 para n (comunicação em grupo)</li>
<li>Totalmente Ordenada: todos os processos entregam as mensagens na mesma ordem</li>
</ul>
</li>
<li>Difusão Causalmente Ordenada:<ul>
<li>Causalmente Ordenada: uma mensagem só é entregue se todas as que causalmente a precedem já foram entregues.</li>
</ul>
</li>
</ul>
<p>Com estas abstrações, podemos resolver o problema apresentado no início deste capítulo, relembrando, <em>cloud-drive</em>, da seguinte forma.
Considere um programa qualquer, que se comporte de forma determinística (isto é, dada uma mesma entrada, gera sempre uma mesma saída). 
Como todo programa, este é uma máquina de estados, com a peculiaridade de ser determinística.
Logo, se tivermos <strong>várias cópias</strong> deste programa, executando em locais distintos, mas garantirmos que cada cópia veja exatamente a <strong>mesma entrada de dados</strong>, então garantiremos que todas as cópias <strong>transitarão pelos mesmos estados</strong> e chegarão ao mesmo estado final.
Como difusão totalmente ordenada pode ser usado para garantir que todas as cópias receberão a mesma entrada, pode ser usado para implementar esta técnica, conhecida como Replicação de Máquinas de Estados (em inglês, <a href="https://en.wikipedia.org/wiki/State_machine_replication"><em>State Machine Replication</em></a>, ou pelo menos o seu princípio.</p>
<p><img alt="State Machine Replication" src="drawings/multicast.drawio-1.svg" /></p>
<p>Mas como podemos implementar estas primitivas de difusão usando relógios lógicos? 
Vejamos um algoritmo, onde consideramos que todas as mensagens são enviadas a todos os processos, inclusive o próprio remetente.</p>
<div class="admonition example">
<p class="admonition-title">Difusão Totalmente Ordenado</p>
<ul>
<li>
<p>Considerando o ponto de vista do processo <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span></p>
</li>
<li>
<p><span><span class="MathJax_Preview">f_p</span><script type="math/tex">f_p</script></span> é uma fila de mensagens ordenadas pelo seus <em>timestamps</em>, mantida em <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span></p>
</li>
<li>Para difundir uma mensagem <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span><ul>
<li>colocar <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> na fila</li>
<li>enviar <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> para todos os demais processos</li>
</ul>
</li>
<li>Quando uma mensagem <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> é recebida<ul>
<li>colocar <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> na fila</li>
<li>se <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> não é um ack<ul>
<li>enviar <span><span class="MathJax_Preview">m ack</span><script type="math/tex">m ack</script></span> de volta ao remetente de <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> (com <em>timestamp</em> maior que de <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>)</li>
</ul>
</li>
</ul>
</li>
<li>Seja <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> a mensagem com <em>timestamp</em> ts na cabeça da fila<ul>
<li>Se para cada processo <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>, há uma mensagem <span><span class="MathJax_Preview">m'</span><script type="math/tex">m'</script></span> de <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> com <em>timestamp</em> ts' na fila de <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> tal que <span><span class="MathJax_Preview">ts &lt; ts'</span><script type="math/tex">ts < ts'</script></span><ul>
<li>entregar <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> para a aplicação</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p>O objetivo deste algoritmo é de entregar mensagens na ordem de seus <em>timestamps</em>. Para isso, antes de entregar a mensagem <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> de menor <em>tmestamp</em> ts conhecido atualmente por <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span>, <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> espera por mensagens com <span><span class="MathJax_Preview">timestamps</span><script type="math/tex">timestamps</script></span> maiores que ts de todos os processos. Uma vez que isso aconteça, <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> sabe que nenhuma outra mensagem que chegue depois poderia ter <span><span class="MathJax_Preview">timestamp</span><script type="math/tex">timestamp</script></span> menor que ts.
Para que isto funcione, é necessário que os canais de comunicação usados sejam confiáveis (todas as mensagens enviadas são entregues) e FIFO (a primeira a ser enviada é primeira a ser recebida).</p>
<div class="admonition exercise">
<p class="admonition-title">Exercício - FIFO e Confiáveis</p>
<p>É necessário que canais de comunicação sejam FIFO e confiáveis para que mensagens com <em>timestamp</em> maiores não sejam perdidas e para que mensagens com <em>timestamps</em> maiores não sejam reordenadas e entregues primeiro. </p>
<p>Explique porquê isto seria um problema; descreva execuções problemáticas.</p>
</div>
<p>Vejamos um outro algoritimo, de difusão <strong>causalmente</strong> ordenada.</p>
<div class="admonition example">
<p class="admonition-title">Difusão Causalmente Ordenada</p>
<ul>
<li>
<p>Considerando o ponto de vista do processo <span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span></p>
</li>
<li>
<p><span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> incrementa <span><span class="MathJax_Preview">c_p[p]</span><script type="math/tex">c_p[p]</script></span> somente no envio de mensagens.</p>
</li>
<li><span><span class="MathJax_Preview">p</span><script type="math/tex">p</script></span> só entrega uma mensagem recebida de <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span>, com timestamp <span><span class="MathJax_Preview">ts</span><script type="math/tex">ts</script></span> quando<ul>
<li><span><span class="MathJax_Preview">ts[q] = c_p[q]+1</span><script type="math/tex">ts[q] = c_p[q]+1</script></span></li>
<li><span><span class="MathJax_Preview">ts[k] \leq c_p[k], k \neq q</span><script type="math/tex">ts[k] \leq c_p[k], k \neq q</script></span></li>
</ul>
</li>
</ul>
</div>
<p><img alt="causal" src="images/tanenbaum-06-13.png" /></p>
<div class="admonition exercise">
<p class="admonition-title">Difusão Causalmente Ordenada</p>
<p>Considere <span><span class="MathJax_Preview">c_{P_2}[0,2,2]</span><script type="math/tex">c_{P_2}[0,2,2]</script></span> e <span><span class="MathJax_Preview">ts=[1,3,0]</span><script type="math/tex">ts=[1,3,0]</script></span>, de <span><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span>. O que <span><span class="MathJax_Preview">P_2</span><script type="math/tex">P_2</script></span> está esperando? Como age ao receber mensagem com <span><span class="MathJax_Preview">ts</span><script type="math/tex">ts</script></span>?</p>
</div>
<p>Um aspecto interessante da implementação de primitivas de comunicação em grupo que usa relógios para ordenação de mensagens é que elas podem ser feitas de forma transparente para a aplicação que as usa. 
Isto é, no exemplo descrito anteriormente em que processos mandam mensagens para réplicas usando difusão totalmente ordenada, os clientes não precisam estar cientes disto, e podem simplesmente mandar suas requisições como faziam antes do serviço ser replicado. Mas como então as mensagens tem seus relógios lógicos atualizados e usados para a geração de <em>timestamps</em>?
Isto pode ser feito por meio de <strong>interceptadores</strong> em uma camada de <strong><em>middleware</em></strong>.</p>
<p><img alt="Interceptadores" src="images/tanenbaum-06-10.png" /></p>
<p>Quando a aplicação envia uma mensagem, o relógio lógico mantido no <em>middleware</em> é atualizado e seu valor usado como <em>timestamp</em> em uma versão estendida da mensagem, efetivamente enviada na rede.
Quando a mensagem estendida é entregue ao destinatário, a mensagem é passada para o interceptador que extrai o <em>timestamp</em> e atualiza seu relógio. A mensagem sem o <em>timestamp</em> é entregue para a aplicação quando apropriado, e aplicação não percebe a manipulação.</p>
<h3 id="exclusao-mutua-revisitada">Exclusao Mútua Revisitada</h3>
<details class="todo"><summary>Todo</summary><ul>
<li><a href="http://www.cs.cmu.edu/~dga/15-440/F10/lectures/Distributed-Mutual-Exclusion-slides.pdf">Algoritmos de Excluão mútua baeados em LC</a></li>
<li>Algoritmo de Lamport, Ricart e agrawalla</li>
<li><a href="https://www.coursera.org/learn/cloud-computing-2/lecture/GMHYN/2-4-maekawas-algorithm-and-wrap-up">Algoritmo de Maekawa</a></li>
</ul>
</details>
<div class="footnote">
<hr />
<ol>
<li id="fn:quartz">
<p><a href="https://www.explainthatstuff.com/quartzclockwatch.html">Explain that stuff.</a>&#160;<a class="footnote-backref" href="#fnref:quartz" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:piezo">
<p>Distorção mecânica gera corrente elétrica e submissão a uma corrente elétrica gera uma distorção mecânica.&#160;<a class="footnote-backref" href="#fnref:piezo" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:freq">
<p>32768 é a primeira potência de 2 maior que 20000, a maior frequência sonora audível aos seres humanos.&#160;<a class="footnote-backref" href="#fnref:freq" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:ntpfigure">
<p><a href="https://commons.wikimedia.org/w/index.php?curid=2815097">Fonte: Benjamin D. Esham, (bdesham) - Based upon Ntp.png by Kim Meyrick</a>&#160;<a class="footnote-backref" href="#fnref:ntpfigure" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:rfc1305">
<p><a href="https://datatracker.ietf.org/doc/rfc1305/">RFC 1305</a>, 1991/1992&#160;<a class="footnote-backref" href="#fnref:rfc1305" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:rfc5905-5908">
<p>RFC 5905-5908,2010&#160;<a class="footnote-backref" href="#fnref:rfc5905-5908" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:ieee1588">
<p><a href="https://www.nist.gov/el/intelligent-systems-division-73500/ieee-1588">IEEE 1588TM Standard for A Precision Clock Synchronization Protocol for Networked Measurement and Control Systems</a>.&#160;<a class="footnote-backref" href="#fnref:ieee1588" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:liskov">
<p><a href="http://rdcu.be/s4iy">Liskov, B.: Distrib Comput (1993) 6: 211. doi:10.1007/BF02242709</a>&#160;<a class="footnote-backref" href="#fnref:liskov" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:usd">
<p>Unidade Simples de Dinheiros.&#160;<a class="footnote-backref" href="#fnref:usd" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
<li id="fn:tiebreak">
<p>Empates são quebrados pelo identificador do processo, isto é, se duas mensagens são produzidas ao mesmo tempo por U1 e U2, então o a mensagem de U1 tem precedência na execução.&#160;<a class="footnote-backref" href="#fnref:tiebreak" title="Jump back to footnote 10 in the text">&#8617;</a></p>
</li>
<li id="fn:tempologico">
<p>Reza a lenda que Leslie Lamport desenvolveu o conceito de relógios lógicos pensando na teoria da relatividade geral.&#160;<a class="footnote-backref" href="#fnref:tempologico" title="Jump back to footnote 11 in the text">&#8617;</a></p>
</li>
<li id="fn:tcoeds">
<p><a href="http://amturing.acm.org/p558-lamport.pdf">Time, Clocks and the Ordering of Events in a Distributed System. July 5, 1978</a>.&#160;<a class="footnote-backref" href="#fnref:tcoeds" title="Jump back to footnote 12 in the text">&#8617;</a></p>
</li>
<li id="fn:matrix_clock">
<p><a href="https://en.wikipedia.org/wiki/Matrix_clock">Matrix Clock</a>&#160;<a class="footnote-backref" href="#fnref:matrix_clock" title="Jump back to footnote 13 in the text">&#8617;</a></p>
</li>
<li id="fn:hlc">
<p>O <a href="http://muratbuffalo.blogspot.com/2014/07/hybrid-logical-clocks.html">blog</a> de um dos autores descreve ambas as versões de forma resumida. Para a versão completa dos algoritmos, consulte o <a href="http://www.cse.buffalo.edu/tech-reports/2014-04.pdf">artigo</a>.&#160;<a class="footnote-backref" href="#fnref:hlc" title="Jump back to footnote 14 in the text">&#8617;</a></p>
</li>
<li id="fn:hlcerror">
<p>Tanto no artigo quanto no blog, a imagem que descreve um exemplo do HLC parece ter um erro e onde se lê (3,13) deve-se ler (3,10,3).&#160;<a class="footnote-backref" href="#fnref:hlcerror" title="Jump back to footnote 15 in the text">&#8617;</a></p>
</li>
</ol>
</div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../coord/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Coordenação
              </div>
            </div>
          </a>
        
        
          <a href="../fault/" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Tolerância a Falhas
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.fd16492e.min.js"></script>
      <script src="../assets/javascripts/bundle.7836ba4d.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: [],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
    
  </body>
</html>