
<!doctype html>
<html lang="pt" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.1.3">
    
    
      
        <title>Bancos de Dados - Notas em Sistemas Distribuídos</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.e35208c4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ef6f36e2.min.css">
        
          
          
          <meta name="theme-color" content="#546d78">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="../css/extra.css">
    
    
      
        
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","G-PJX835H7DP","lasarojc.github.org/dsnotes"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){var e;this.value&&(e=document.location.pathname,ga("send","pageview",e+"?q="+this.value))}),"undefined"!=typeof location$&&location$.subscribe(function(e){ga("send","pageview",e.pathname)})})</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="deep-orange">
  
    
    <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#transacoes" class="md-skip">
          Ir para o conteúdo
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Notas em Sistemas Distribuídos" class="md-header__button md-logo" aria-label="Notas em Sistemas Distribuídos" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Notas em Sistemas Distribuídos
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Bancos de Dados
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Buscar" placeholder="Buscar" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/lasarojc/ds_notes" title="Ir ao repositório" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Notas em Sistemas Distribuídos" class="md-nav__button md-logo" aria-label="Notas em Sistemas Distribuídos" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Notas em Sistemas Distribuídos
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/lasarojc/ds_notes" title="Ir ao repositório" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../preface/" class="md-nav__link">
        Prefácio
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../intro/" class="md-nav__link">
        Introdução
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../fundamentals/" class="md-nav__link">
        Fundamentos
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../arch/" class="md-nav__link">
        Arquiteturas
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../comm/" class="md-nav__link">
        Comunicação
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../coord/" class="md-nav__link">
        Coordenação
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../time/" class="md-nav__link">
        Tempo
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../fault/" class="md-nav__link">
        Tolerância a Falhas
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../consistency/" class="md-nav__link">
        Consistência
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Bancos de Dados
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Bancos de Dados
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Índice">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Índice
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#transacoes" class="md-nav__link">
    Transações
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#equivalencia-serial" class="md-nav__link">
    Equivalência Serial
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#controle-de-concorrencia" class="md-nav__link">
    Controle de Concorrência
  </a>
  
    <nav class="md-nav" aria-label="Controle de Concorrência">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#locking" class="md-nav__link">
    Locking
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multi-versao" class="md-nav__link">
    Multi-versão
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamping" class="md-nav__link">
    Timestamping
  </a>
  
    <nav class="md-nav" aria-label="Timestamping">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#como-implementar" class="md-nav__link">
    Como implementar
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#como-implementar-escrita" class="md-nav__link">
    Como implementar -- escrita
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#como-implementar-leitura" class="md-nav__link">
    como implementar -- leitura
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bancos-de-dados-distribuidos" class="md-nav__link">
    Bancos de dados distribuídos
  </a>
  
    <nav class="md-nav" aria-label="Bancos de dados distribuídos">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#transacao-distribuida" class="md-nav__link">
    Transação distribuída
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comprometimento-distribuido" class="md-nav__link">
    Comprometimento distribuído
  </a>
  
    <nav class="md-nav" aria-label="Comprometimento distribuído">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1pc" class="md-nav__link">
    1PC
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2pc" class="md-nav__link">
    2PC
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-pc" class="md-nav__link">
    3-PC
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#paxos-commit" class="md-nav__link">
    Paxos-Commit
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#log-structured-merge-trees" class="md-nav__link">
    Log Structured Merge Trees
  </a>
  
    <nav class="md-nav" aria-label="Log Structured Merge Trees">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#compactacoes" class="md-nav__link">
    Compactações
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#filtros-de-bloom" class="md-nav__link">
    Filtros de Bloom
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cap" class="md-nav__link">
    CAP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#referencias" class="md-nav__link">
    Referências
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../disfs/" class="md-nav__link">
        Sistemas de Arquivos
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../tech/" class="md-nav__link">
        Tecnologias
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../projeto/" class="md-nav__link">
        Projeto
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Índice">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Índice
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#transacoes" class="md-nav__link">
    Transações
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#equivalencia-serial" class="md-nav__link">
    Equivalência Serial
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#controle-de-concorrencia" class="md-nav__link">
    Controle de Concorrência
  </a>
  
    <nav class="md-nav" aria-label="Controle de Concorrência">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#locking" class="md-nav__link">
    Locking
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multi-versao" class="md-nav__link">
    Multi-versão
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#timestamping" class="md-nav__link">
    Timestamping
  </a>
  
    <nav class="md-nav" aria-label="Timestamping">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#como-implementar" class="md-nav__link">
    Como implementar
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#como-implementar-escrita" class="md-nav__link">
    Como implementar -- escrita
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#como-implementar-leitura" class="md-nav__link">
    como implementar -- leitura
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bancos-de-dados-distribuidos" class="md-nav__link">
    Bancos de dados distribuídos
  </a>
  
    <nav class="md-nav" aria-label="Bancos de dados distribuídos">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#transacao-distribuida" class="md-nav__link">
    Transação distribuída
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comprometimento-distribuido" class="md-nav__link">
    Comprometimento distribuído
  </a>
  
    <nav class="md-nav" aria-label="Comprometimento distribuído">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1pc" class="md-nav__link">
    1PC
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2pc" class="md-nav__link">
    2PC
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-pc" class="md-nav__link">
    3-PC
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#paxos-commit" class="md-nav__link">
    Paxos-Commit
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#log-structured-merge-trees" class="md-nav__link">
    Log Structured Merge Trees
  </a>
  
    <nav class="md-nav" aria-label="Log Structured Merge Trees">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#compactacoes" class="md-nav__link">
    Compactações
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#filtros-de-bloom" class="md-nav__link">
    Filtros de Bloom
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cap" class="md-nav__link">
    CAP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#referencias" class="md-nav__link">
    Referências
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              

<!-- Edit button -->


  <!--
       Hack: check whether the content contains a h1 headline. If it
       doesn't, the page title (or respectively site name) is used
       as the main headline.
    -->

  <h1>Bancos de Dados</h1>


  <!-- Content -->
  <p>Voltemo-nos agora aos bancos de dados mais tradicionais, isto é, bancos de dados relacionais.
Destaco que quando falamos em bancos de dados relacionais, geralmente pensamos em bancos de dados transacionais, mas o que são transações?</p>
<h2 id="transacoes">Transações</h2>
<p>No banco de dados vistos no capítulo anterior, <strong>operações</strong> são enviadas <strong>individualmente</strong> para as réplicas do banco.
Já no modelo transacional, normalmente pensamos em <strong>conjunto de operações</strong> em vez de operações individuais; estes conjuntos de operações são as <strong>transações</strong>.</p>
<p>Considere um sistema bancário que mantém contas com saldos inteiros.
Seguindo a notação apresentada anteriormente, <span class="arithmatex">\(R(C)10\)</span> é um operação de leitura da conta <span class="arithmatex">\(C\)</span> que retorna o valor 10 e <span class="arithmatex">\(W(C)20\)</span> é a operação de atualização do saldo de <span class="arithmatex">\(C\)</span> para 20.
Vamos estender a notação para que <span class="arithmatex">\(a = R(C)\)</span>  armazene o valor lido de <span class="arithmatex">\(C\)</span> em <span class="arithmatex">\(a\)</span>.
Seja <span class="arithmatex">\(T\)</span> uma transação que incrementa o valor de uma conta em <span class="arithmatex">\(1\)</span>; ela pode ser especificada como </p>
<p><span class="arithmatex">\(a = R(C); W(C)a+1\)</span></p>
<p>Imagine duas instâncias desta transação executando serialmente. 
Ao final da execução o saldo foi acrescido de 2, como esperado.</p>
<p><img alt="transações" src="../drawings/transactions.drawio-0.svg" /></p>
<p>Se em vez disso as duas instâncias executassem concorrentemente, teríamos um resultado diverso, mesmo que o esperado fosse o mesmo resultado.</p>
<p><img alt="transações" src="../drawings/transactions.drawio-1.svg" /></p>
<p>Ao final da execução, apesar do valor ter sido modificado duas vezes, o saldo teria sido acrescido de 1.
Esta diferença entre o esperado e o real está enraizada nas garantias dadas por bancos de dados tradicionais, conhecidas como ACID, acrônimo para <strong>Atomicidade, Consistência, Isolamento e Durabilidade</strong>.</p>
<details class="sideslide"><summary>ACID</summary><ul>
<li>Atomicidade</li>
<li>Consistência</li>
<li>Isolamento</li>
<li>Durabilidade</li>
</ul>
</details>
<p>A atomicidade diz respeito ao tratamento das operações como um conjunto indivisível, isto é, <strong>ou todas as operações no conjunto são executadas ou nenhuma é.</strong></p>
<p>A propriedade de consistência dita que todas as transições do banco de dados devem <strong>respeitar restrições nos seus dados</strong>, por exemplo, os tipos de cada entrada no banco e integridade referencial.</p>
<p>Já a propriedade de isolamento se refere a como e quando os efeitos de uma transação passam a ser visíveis para outras transações, possivelmente concorrentes.
Há diversos níveis de isolamento, sendo menos restritivos, como <strong>consistência eventual</strong><sup id="fnref:cons"><a class="footnote-ref" href="#fn:cons">1</a></sup>, ou mais restritivo, como <strong>seriabilidade estrita</strong>.</p>
<p>Finalmente, durabilidade é a garantia de que os resultados de uma transação são permanentemente gravados no sistema, a despeito de falhas.</p>
<p>Caso estas propriedades não sejam garantidas na execução de transações, problemas podem acontecer, como no exemplo anterior.
Por exemplo, seja uma transação que move 10% do saldo da segunda conta da primeira para a segunda, isto é, se <span class="arithmatex">\(a\)</span> tem saldo inicial 50 e <span class="arithmatex">\(b\)</span> tem saldo inicial 100, a transação transfere 10 de <span class="arithmatex">\(a\)</span> para <span class="arithmatex">\(b\)</span>.</p>
<table>
<thead>
<tr>
<th>T1(a,b)</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(a)sA - (sB*0.1)\)</span></td>
</tr>
</tbody>
</table>
<p>E seja uma transação que calcule o somatório dos saldos em todas as contas especificadas, isto é, se aplicada às contas <span class="arithmatex">\(a\)</span> e <span class="arithmatex">\(b\)</span> do exemplo anterior, retorna 150 como resultado.</p>
<table>
<thead>
<tr>
<th>T2([a,b])</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(sT = sA + sB\)</span></td>
</tr>
</tbody>
</table>
<p>Agora, seja uma execução concorrente destas transações da seguinte forma (tempo passa para baixo) e que o saldo inicial de <span class="arithmatex">\(a\)</span> e <span class="arithmatex">\(b\)</span> são ambos 10.</p>
<table>
<thead>
<tr>
<th>T1(a,b)</th>
<th>T2([a,b])</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
<td></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(a)sA - (sB*0.1)\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sT = sA+sB\)</span></td>
</tr>
</tbody>
</table>
<p>Qual o valor final calculado?</p>
<details class="example"><summary>Execução</summary><p>Se <span class="arithmatex">\(a\)</span> inicialmente tem 50 e <span class="arithmatex">\(b\)</span> 100, então a seguinte execução ocorre:</p>
<table>
<thead>
<tr>
<th>T1(a,b)</th>
<th>T2([a,b])</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(sB = R(b)\)</span> = 100</td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sA = R(a) = 50\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span> = 110</td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sB = R(b) = 110\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(sA = R(a) = 50\)</span></td>
<td></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(a)sA - (sB*0.1) = 40\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sT = sA+sB = 160\)</span></td>
</tr>
</tbody>
</table>
</details>
<p>O problema aqui é que dados sendo modificados, isto é, não finais, "vazaram" de T1 para T2, um fenômeno conhecido como <strong><em>dirty read</em></strong>.
Isso ocorreu porquê o nível de isolamento provido foi nenhum.</p>
<p>Supondo uma execução de duas instâncias de T1, podemos observar outro problema, que pode deixar o BD em estado inválido.</p>
<table>
<thead>
<tr>
<th>T1(a,b)</th>
<th>T1(a,b)</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(b) sB*1.1\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(W(a)sA-(sB*0.1)\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
<td></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(a)sA-sB*0.1\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<details class="example"><summary>Execução</summary><p>Se <span class="arithmatex">\(a\)</span> inicialmente tem 50 e <span class="arithmatex">\(b\)</span> 100, então a seguinte execução ocorre:</p>
<table>
<thead>
<tr>
<th>T1(a,b)</th>
<th>T1(a,b)</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(sB = R(b) = 100\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sB = R(b) = 100\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(W(b)sB*1.1 = 110\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(b) sB*1.1\)</span> = 110</td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sA = R(a) = 50\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(W(a)sA-(sB*0.1) = 40\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(sA = R(a) = 40\)</span></td>
<td></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(a)sA-sB*0.1 = 30\)</span></td>
<td></td>
</tr>
</tbody>
</table>
</details>
<p>Observe que <span class="arithmatex">\(sB*0.1\)</span> foi perdido, o que é conhecido como <strong><em>lost update</em></strong>, agora porquê faltou isolamento.</p>
<p>Qual a solução? No primeiro exemplo deste capítulo, uma execução serial das operações não causou problema, enquanto a concorrente sim.
Testemos novamente uma <strong>execução</strong> em que as transações não se sobrepõem.</p>
<table>
<thead>
<tr>
<th>T1(a,b)</th>
<th>T1(a,b)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(W(a)sA-(sB*0.1)\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
<td></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
<td></td>
</tr>
<tr>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
<td></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(a)sA-sB*0.1\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<p>Esta solução funciona, mas, na prática, queremos o máximo de <strong>concorrência</strong> para garantir o melhor <strong>desempenho</strong>.
O que queremos então é uma execução das transações semelhante à serial, para garantir a corretude dos resultados, mas com o desempenho garantido pela execução concorrente.
Isto é, <strong>não queremos uma execução serial</strong>, queremos uma execução <strong>equivalente a uma execução serial</strong>.</p>
<h2 id="equivalencia-serial">Equivalência Serial</h2>
<p>De forma geral, dizemos que duas execuções de transações são equivalentes se</p>
<ul>
<li>são execuções das mesmas transações (mesmas operações)</li>
<li>quaisquer duas operações conflitantes são executadas na mesma ordem nas duas execuções.</li>
</ul>
<p>Duas operações são conflitantes se </p>
<ul>
<li>pertencem a transações diferentes,</li>
<li>operam no mesmo dado, e</li>
<li>pelo menos uma delas é escrita.</li>
</ul>
<p>Uma execução tem <strong>equivalência serial</strong> se é equivalente a alguma execução serial das transações.
Ora, se uma execução é equivalente a uma execução serial e a execução serial não tem problemas relacionados a isolamento, pois não há transação concorrente que acesse dados incompletos, então a execução serial garante resultados corretos.
Assim, para obter tanto desempenho advindo da concorrência quanto corretude advinda da serialização, escalone as operações de forma a garantir equivalência serial.</p>
<p>Mas como obter equivalência serial? Não seria viável executar as operações e demonstrar <em>post facto</em> que a execução é correta.
Em vez disso, precisamos garantir por construção a equivalência serial, o que é bem mas simples, principalmente se considerarmos a seguinte restrição</p>
<ul>
<li>a execução de duas transações tem Equivalência Serial se todos os pares de operações conflitantes entre as transações são executados na mesma ordem.</li>
</ul>
<p>Revisitemos o exemplo do <em>lost update</em>. Quais operações conflitam nesta execução?</p>
<details class="sideslide"><summary>Conflitos</summary><p>Conflitos: 1x3:<span class="arithmatex">\(\rightarrow\)</span>, 2x4:<span class="arithmatex">\(\leftarrow\)</span>, 3x4:<span class="arithmatex">\(\leftarrow\)</span></p>
</details>
<table>
<thead>
<tr>
<th>Operação</th>
<th>T1(a,b)</th>
<th>T1(c,b)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
<td></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td></td>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td></td>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><span class="arithmatex">\(sC = R(c)\)</span></td>
</tr>
<tr>
<td></td>
<td></td>
<td><span class="arithmatex">\(W(c)sC-sB*0.1\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(W(a)sA-sB*0.1\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<p>Claramente, os pares (1,3), (2,4) e (3,4) são conflitantes. Para se obter equivalência serial então é necessário garantir que em todos os pares se executem as operações na mesma ordem, isto é, ou da esquerda para a direita ou da direita para a esquerda.
Observe que este não é o caso neste exemplo.
Mas e se modificarmos a execução como a seguir?</p>
<details class="sideslide"><summary>Conflitos</summary><p>Conflitos: 1x3:<span class="arithmatex">\(\leftarrow\)</span>, 2x4:<span class="arithmatex">\(\leftarrow\)</span>, 3x4:<span class="arithmatex">\(\leftarrow\)</span></p>
</details>
<table>
<thead>
<tr>
<th>Operação</th>
<th>T1(a,b)</th>
<th>T1(c,b)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>2</strong></td>
<td></td>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td></td>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
<td></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><span class="arithmatex">\(sC = R(c)\)</span></td>
</tr>
<tr>
<td></td>
<td></td>
<td><span class="arithmatex">\(W(c)sC-sB*0.1\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(W(a)sA-sB*0.1\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<p>Neste exemplo modificado teremos as operações nos pares de conflitos sendo executadas da direita para a esquerda, o que garante a equivalência serial da execução.
Contudo, o modelo de transações usado até agora, em que o conjunto de operações é sempre executado até o fim, não corresponde à realidade.
Precisamos adicionar a este modelo a possibilidade da transação ser <strong>abortada</strong>, isto é, ter seus efeitos revertidos.
Sob este novo modelo, considere o seguinte exemplo, onde a transação da direita é abortada.</p>
<table>
<thead>
<tr>
<th>T1(a,b)</th>
<th>T1(c,b)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(sB = R(b)\)</span></td>
<td></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(b)sB*1.1\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(sC = R(c)\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="arithmatex">\(W(c)sC-sB*0.1\)</span></td>
</tr>
<tr>
<td><span class="arithmatex">\(sA = R(a)\)</span></td>
<td></td>
</tr>
<tr>
<td><span class="arithmatex">\(W(a)sA-sB*0.1\)</span></td>
<td></td>
</tr>
<tr>
<td></td>
<td>aborte!</td>
</tr>
</tbody>
</table>
<p>Apesar das operações serem ordenadas da direita para a esquerda, houve um <em>dirty read</em> na execução da transação da esquerda.
Uma forma de pensar em como isso aconteceu, é considerar que o <strong>aborte!</strong> é uma operação que toca todos os dados usados pela transação abortada.
Assim, o <strong>aborte!</strong> conflita com as leituras de <span class="arithmatex">\(b\)</span> e de <span class="arithmatex">\(a\)</span> feitas pela transação da esquerda e, portanto, houve uma violação na ordem de execução das operações.</p>
<p>Para que este dirty read não leve a inconsistências, a transação da esquerda deve também abortar.
Esta estratégia pode ser implementada da seguinte forma: </p>
<ul>
<li>se uma transação lê um dado atualizado por uma transação não comitada, suspenda a transação executando a leitura.</li>
<li>se transação que atualizou o dado foi abortada, todas as suspensas que leram dela devem ser abortadas.</li>
<li>repita passo anterior.</li>
</ul>
<p>Graficamente, podemos ver o exemplo acima assim, tanto no caso de commit quando de abort da segunda transação.</p>
<p><img alt="suspended execution" src="../drawings/transactions.drawio-2.svg" /></p>
<p>Apesar de correta, esta abordagem tem um caso patológico que leva a <strong>abortos em Cascata</strong>: 
se T1 lê algo que T2 escreveu, e T2 lê algo que T3 escreveu, e assim por diante, se a última transação nesta cadeia de dependências for abortada, todas deverão ser abortadas.</p>
<p><img alt="suspended execution" src="../drawings/transactions.drawio-3.svg" /></p>
<p>Mas, e se evitarmos dirty reads em vez de tratarmos? Podemos fazê-lo com a seguinte estratégia:</p>
<ul>
<li>quando um transação T1 tenta ler um dado "sujo" escrito por T2, suspenda a execução da transação T1, antes da leitura acontecer.</li>
<li>quando transação T2 for terminada, continue a execução de T1.</li>
</ul>
<p><img alt="suspended execution" src="../drawings/transactions.drawio-3.svg" /></p>
<p>O que estamos tentando obter aqui é uma <strong>execução estrita</strong>, ou seja, uma execução em que Leituras e Escritas devem ser atrasadas até que todas as transações anteriores que contenham escritas nos mesmos dados sejam "comitadas" ou abortadas. Execuções estritas garante Isolamento, contudo, levam a menor concorrência, já que transações ficam suspensas.
Fica então a pergunta: <strong>como implementar execuções estritas eficientes</strong>?
A resposta está no controle de concorrência das transações.</p>
<h2 id="controle-de-concorrencia">Controle de Concorrência</h2>
<p>Consideremos três abordagens de controle de concorrência usadas por bancos de dados:</p>
<ul>
<li>locking: abordagem pessimista que paga um alto preço de sincronização mesmo quando as transações não interferem umas nas outras.</li>
<li>multi-versão: abordagem otimista, que tem algo custo quando há muitos conflitos entre as transações.</li>
<li>timestamp: abordagem mais complexa de se implementar.</li>
</ul>
<h3 id="locking">Locking</h3>
<p>Nesta abordagem, todos os objetos usados por uma transação são trancados, impedindo que sejam acessados por outras transações, até que sejam destrancados.
Contudo, se os objetos são destrancados tão logo não sejam mais usados na transação, continuamos a ter <em>dirty reads</em>, como a operação em vermelho na figura a seguir.</p>
<p><img alt="suspended execution" src="../drawings/transactions.drawio-4.svg" /></p>
<p>Mesmo que se tentasse abortar a transação que executou a <em>dirty read</em>, poderia ser tarde demais, como no exemplo a seguir que demonstra uma <strong>escrita prematura</strong>.</p>
<p><img alt="suspended execution" src="../drawings/transactions.drawio-5.svg" /></p>
<p>Estes problemas podem ser evitados com o uso de <strong><em>strict two phase locking</em></strong>, em que as transações <strong>trancam o objeto quando primeiro acessado</strong> e só <strong>destrancam ao final da transação</strong>, atomicamente com a terminação.</p>
<p><img alt="suspended execution" src="../drawings/transactions.drawio-6.svg" /></p>
<p>Já para aumentar a concorrência, é possível usar locks para leitura, compartilhados, e para escrita, exclusivos.</p>
<details class="sideslide"><summary>Read/Write locks</summary><ul>
<li>dois níveis de acesso</li>
<li>múltiplos leitores</li>
<li>único escritor</li>
<li>reads por ser transformados em locks</li>
<li>writes <em>não</em> podem se transformados em reads (violaria Strict Two-Phase Locking)</li>
</ul>
</details>
<p>Ou, ainda, locks com diferentes granularidades; em um banco de dados relacional, por exemplo, pode ser possível obter um lock em uma coluna de uma linha do banco, de toda a linha, de toda a relação, ou mesmo de todo o banco de dados.</p>
<p>Mas mesmo com estes ajustes, locks deveriam, via de regra, serem evitados sempre que a probabilidade de conflitos for baixa. 
Isso porquê os locks são uma abordagem <strong>pessimista</strong>, que incorrem em <strong><em>overhead</em></strong> mesmo quando transações não acessam os mesmos dados, lembrando que os locks só podem ser liberados no final das transações.</p>
<details class="sideslide"><summary>Evitar locks</summary><ul>
<li>pessimista</li>
<li>overhead mesmo se não há conflitos</li>
<li>ou restritivo ou risco de deadlock</li>
<li>lock liberado somente no final, para evitar dirty reads/escrita prematura.</li>
</ul>
</details>
<h3 id="multi-versao">Multi-versão</h3>
<p>Uma alternativa otimista aos locks é assumir que não há conflitos nas transações enquanto elas executam e, somente ao final da execução, testar a validade desta premissa e, caso falhe, abortar a transação.
O controle de concorrência multi-versão (MVCC, do termo em inglês) faz isso mantendo uma cópia privada dos dados acessados pela transação.
Ao final da execução, na fase de <strong>validação</strong>, se a cópia pública de onde a privada foi copiada não tiver sido modificada, a transação é bem sucedida e atualizações são feitas nas cópias públicas.<sup id="fnref:atu"><a class="footnote-ref" href="#fn:atu">2</a></sup></p>
<p>Esta técnica, conhecida como <em>deferred update</em> pois atrasa a atualização da cópia pública até o final da transação, tem como vantagens o <strong>baixo</strong> <strong><em>overhead</em></strong>, se não houver conflitos.
Entretanto, se houver muitos conflitos, o trabalho da transação é todo desperdiçado já que a transação será abortada na <strong>validação</strong>.</p>
<p>A validação consiste em verificar se os <em>read</em> e <em>write sets</em> de quaisquer transações concorrentes são disjuntos, isto é, se dados transações <span class="arithmatex">\(t1\)</span> e <span class="arithmatex">\(t2\)</span>:</p>
<ul>
<li>t1 não deve ler dados escritos por t2</li>
<li>t2 não deve ler dados escritos por t1</li>
<li>t1/t2 não deve escrever dados escritos por t2/t1</li>
</ul>
<p>Na imagem a seguir, a transação <strong>preta</strong> precisa ser validada ou frente às transações <strong>concorrentes</strong> vermelhas, já comitadas, ou às azuis, ainda por comitar.</p>
<p><img alt="" src="../images/trans_validation.png" /></p>
<p>No caso da validação com transações já comitadas (<strong><em>backward validation</em></strong>) a validação pode ser simplificada assim:</p>
<ul>
<li>t1: transação sendo validada</li>
<li>t2: transação já comitada.</li>
<li>t1 não deve ler dados escritos por t2</li>
</ul>
<p>Se a validação for com as transações ainda em execução (<strong><em>forward validation</em></strong>) a regra passa a ser:</p>
<ul>
<li>t1: transação sendo validada</li>
<li>t2: transação ainda em execução</li>
<li>t2 não deve ler dados escritos por t1</li>
</ul>
<p>É preciso destacar que a <strong><em>forward validation</em></strong> pode levar a um cenário em que nenhuma transação é jamais comitada, pois uma cascata de aborts pode ocorrer.</p>
<h3 id="timestamping">Timestamping</h3>
<p>Uma terceira forma de controlar a concorrência associando uma ordem lógica para a execução das transações, de acordo com o início das transações.
Isto é feito atribuindo-se um timestamp a cada transação e garantindo-se que a execução das transações seja é equivalente à execução serial de acordo com os timestamps.<sup id="fnref:kth"><a class="footnote-ref" href="#fn:kth">3</a></sup></p>
<ul>
<li>transação recebe um <em>timestamp</em> no início</li>
<li>operações são validadas na execução<ul>
<li>leia somente se nenhuma transação com maior timestamp tiver escrito e comitado</li>
<li>escreva somente se nenhuma transação com maior timestamp tiver lido e comitado</li>
</ul>
</li>
<li>transações "executam na ordem do timestamp"</li>
</ul>
<p>Como implementar?</p>
<h4 id="como-implementar">Como implementar</h4>
<ul>
<li>objetos tem valores <em>tentativos</em>, não comitados</li>
<li>objetos tem versões em que foram escritos</li>
<li>em que foram comitados</li>
<li>e em que foram lidos</li>
</ul>
<p><img alt="" src="../images/timestamp1.png" /></p>
<ul>
<li>consistência é testado na execução da operação</li>
</ul>
<h4 id="como-implementar-escrita">Como implementar -- escrita</h4>
<ul>
<li>escritas tem sucesso somente se versão sendo escrita é maior que versões lidas</li>
<li>se versão sendo escrita é menor que versão já escrita, ignore e continue</li>
</ul>
<p><img alt="" src="../images/timestamp1.png" /></p>
<h3 id="como-implementar-leitura">como implementar -- leitura</h3>
<ul>
<li>leitura com versão v tem sucesso se maior versão é comitada e menor que v ou alguma não comitada</li>
<li>leitura com versão v é suspensa se maior versão é não comitada e menor que v</li>
</ul>
<p><img alt="" src="../images/timestamp2.png" /></p>
<ul>
<li>leitura com versão v é abortada se maior versão comitada é maior que v
<img alt="" src="../images/timestamp3.png" /></li>
</ul>
<h2 id="bancos-de-dados-distribuidos">Bancos de dados distribuídos</h2>
<p>Agora que relembramos como transações funcionam e temos uma noção de como podem ser implementadas em um sistema centralizado, vamos tentar entender como fazê-lo em um sistema distribuído.</p>
<ul>
<li>múltiplos servidores</li>
<li>transações em cada servidor</li>
<li>transações distribuídas</li>
<li>como obter equivalência serial em transações distribuídas</li>
</ul>
<h3 id="transacao-distribuida">Transação distribuída</h3>
<ul>
<li><code>begintransaction(): tid</code> (transaction id)</li>
<li><code>operation(tid,op)</code></li>
<li><code>endtransaction(tid): ok/nok</code></li>
<li><code>aborttransaction(tid)</code></li>
</ul>
<p>Temos vários papéis sendo desempenhados aqui:</p>
<ul>
<li>cliente</li>
<li>servidor: <em>resource managers</em></li>
<li>servidor: <em>transaction monitor/manager</em></li>
</ul>
<p><img alt="" src="../images/01-10.png" /></p>
<p>Localmente, cada bd funciona como um sistema centralizado normal, usando abordagens otimistas ou pessimista para garantir consistência.</p>
<p>O grande problema no bd distribuído é garantir o <em>acordo</em> na terminação.</p>
<h3 id="comprometimento-distribuido">Comprometimento distribuído</h3>
<p>O problema...</p>
<ul>
<li>transação <span class="arithmatex">\(t\)</span> acessa recursos nos resource managers (rm)</li>
<li>terminar com sucessos <span class="arithmatex">\(t\)</span> em todos os rm - commit - ou</li>
<li>abortar <span class="arithmatex">\(t\)</span> em todos os rm</li>
<li>
<p>ainda que enlaces de comunicação, nós e rm falhem, antes ou durante a terminação da transação.</p>
</li>
<li>
<p>participante -- resource manager "tocados" pela transação</p>
</li>
<li>
<p>coordenador -- transaction manager</p>
</li>
<li>
<p>Cliente decide quando iniciar o commit.</p>
</li>
<li>Cada participante faz commit ou abort da transação local. <br />
    pode retornar ok ou nok.</li>
<li>Coordenador não começa a commit até que a <span class="arithmatex">\(t\)</span> tenha terminado em todos os participantes e cliente tenha solicitado.</li>
<li>Participantes falham por parada.</li>
</ul>
<h4 id="1pc">1PC</h4>
<ul>
<li>cliente envia <code>endtransaction(tid)</code> para o coordenador</li>
<li>coordenador envia mensagem para participantes "comitarem" </li>
</ul>
<p>Mas...</p>
<ul>
<li>e se um participante retornar nok enquanto outros retornam ok?</li>
<li>e se um participante não responder?</li>
</ul>
<h4 id="2pc">2PC</h4>
<ul>
<li>cliente envia <code>endtransaction(tid)</code> para o coordenador</li>
<li>coordenador envia mensagem para participantes se prepararem para terminar</li>
<li>coordenador espera que todos se preparem ou digam se não podem</li>
<li>coordenador envia <em>ordem</em> de terminação</li>
</ul>
<h6>Comprometimento</h6>
<ul>
<li>um participante <span class="arithmatex">\(p\)</span> está pronto para commit se tiver todos os valores modificados por <span class="arithmatex">\(t\)</span> em memória estável e nenhuma razão para abortar a transação (outras transações conflituosas fizeram commit?)</li>
<li>o coordenador não pode começar a terminação até que todos os participantes estejam prontos.</li>
<li>se algum participante aborta, o coordenador deve abortar. </li>
</ul>
<p>Problema de acordo, mas não igual ao consenso.</p>
<h6>2PC - o protocolo</h6>
<ul>
<li>
<p>fase 1</p>
<ul>
<li>a: coordenador envia vote-request para participantes.</li>
<li>b: participante responde com vote-commit ou vote-abort para o coordenador; se vote-abort, aborta localmente.</li>
</ul>
</li>
<li>
<p>fase 2</p>
<ul>
<li>a: coordenador coleta votos de todos os processos; se forem todos vote-commit, envia global-commit para os participantes e ok para o cliente</li>
<li>b: participantes esperam por global-commit ou global-abort</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Coordenador</strong></th>
<th><strong>Participante</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="" src="../images/08-18a.png" /></td>
<td><img alt="" src="../images/08-18b.png" /></td>
</tr>
</tbody>
</table>
<h6>Falha no Participante</h6>
<p>Participante falha no estado <span class="arithmatex">\(S\)</span> e, ao se recuperar, identifica tal fato ao reprocessar o log de operações em memória durável.</p>
<p>Se está no estado</p>
<ul>
<li>INIT:  nem sabia que a terminação começou.  Aborta unilateralmente, pois ou já abortaram ou vão abortar.</li>
<li>ABORT: havia votado abort ou recebido global-abort -- continua protocolo.</li>
<li>COMMIT: estava pronto para terminar a transação com sucesso -- continua protocolo.</li>
<li>READY:  estava esperando por commit ou abort.  Precisa saber se coordenador enviou global-commit ou global-abort -- consulta coordenador.</li>
</ul>
<h6>2PC</h6>
<p>Por que é difícil?</p>
<ul>
<li>E se <span class="arithmatex">\(R_i\)</span> falhar depois de ter se preparado?</li>
<li>E se <span class="arithmatex">\(R_i\)</span> falhar mas <span class="arithmatex">\(R_j\)</span> continuar funcionando?</li>
<li>E se todos estiverem desligados quando <span class="arithmatex">\(R_i\)</span> se recuperar?</li>
<li>E se <span class="arithmatex">\(R_i\)</span> estiver lento e parecer que a transação falhou?</li>
</ul>
<h6>Falha no Participante</h6>
<ul>
<li>READY: esperando por commit ou abort. Precisa saber se coordenador enviou global-commit our global-abort -- consulta coordenador.</li>
</ul>
<p><em>E se coordenador não estiver presente?</em></p>
<p>Assumindo que participantes se conhecem, contate participante <span class="arithmatex">\(Q\)</span>   </p>
<ul>
<li>Se <span class="arithmatex">\(Q\)</span> em COMMIT , vai para COMMIT</li>
<li>Se <span class="arithmatex">\(Q\)</span> em ABORT , vai para ABORT</li>
<li>Se <span class="arithmatex">\(Q\)</span> em INIT , ordena que Q aborte e, se confirmado, veja passo anterior</li>
<li>Se <span class="arithmatex">\(Q\)</span> em READY , consulta outro participante.</li>
</ul>
<p><em>Se todos os participantes em READY?</em>  Possivelmente o coordenador já respondeu ao cliente.</p>
<p><em>Precisa</em> esperar pelo coordenador.</p>
<h6>Falha no Coordenador</h6>
<p>O problema principal é: e se ninguém ouviu a decisão final do coordenador?</p>
<p>Neste caso, o protocolo não pode continuar, enquanto o coordenador não retornar, pois se os RM abortarem, podem estar contradizendo algo dito ao cliente, por exemplo, "Sim, ATM, pode entregar o dinheiro", ou executando um comando que o cliente vê como anulado, como "Reenvie o pedido de mais 27 carros à fábrica."</p>
<h6>Recuperação do Coordenador</h6>
<p>Ao se recuperar, o coordenador:</p>
<ul>
<li>sabe se começou a terminação de alguma transação</li>
<li>sabe se já enviou alguma resposta final para as transações inacabadas</li>
<li>sabe se já recebeu a confirmação de todos os participantes (se transação não estiver em aberto)</li>
<li>reenvia a última mensagem das transações em aberto.</li>
</ul>
<h6>Otimizações</h6>
<ul>
<li>
<p>Participantes "somente-leitura"</p>
<ul>
<li>Não se importa com a decisão; termina após fase 1.</li>
<li>Responde com vote-commit-ro</li>
</ul>
</li>
<li>
<p>Abort presumido</p>
<ul>
<li>Se ocorrer timeout, coordenador envia global-abort a todos e esquece transação</li>
<li>Se questionado, responde com global-abort.</li>
</ul>
</li>
<li>
<p>Transferência de coordenação</p>
<ul>
<li>se houver somente um participante...</li>
<li>vote-request-transfer</li>
<li>participante responde com global-commit/global-abort</li>
</ul>
</li>
</ul>
<h6>Coleta de Lixo</h6>
<p>Mesmo quando somente um participante falha...</p>
<p>Após receber decisão, o participante pode concluir e esquecer a transação. </p>
<p>Mas e se o participante falho precisar se recuperar e todos os outros envolvidos tiverem esquecido a transação?</p>
<p>Coleta de lixo só pode ser feita quando todos tiverem confirmado a execução da transação e, por isso, Fase 2b é necessária.</p>
<h4 id="3-pc">3-PC</h4>
<p>Estende o protocolo para permitir contornar  falha do coordenador.</p>
<h6>O Protocolo</h6>
<ul>
<li>Fase 1a -- Coordenador envia vote-request para participantes.</li>
<li>Fase 1b -- Participante responde com vote-commit ou vote-abort para o coordenador; se vote-abort, aborta localmente.</li>
<li>Fase 2a -- Coordenador coleta votos de todos os processos; se forem todos vote-commit, envia <em>prepare-commit</em> para os participantes; se não, global-abort e para.</li>
<li>Fase 2b -- Participantes esperam por prepare-commit ou global-abort; se o primeiro, <em>respondem com ready-commit</em>; se o segundo, param.</li>
<li>Fase 3a -- coordenador espera por ready-commit de todos e então envia global-commit.</li>
<li>Fase 3b -- participantes esperam por global-commit.</li>
</ul>
<table>
<thead>
<tr>
<th>Coordenador</th>
<th>Participante</th>
</tr>
</thead>
<tbody>
<tr>
<td><img alt="" src="../images/08-22a.png" /></td>
<td><img alt="" src="../images/08-22b.png" /></td>
</tr>
</tbody>
</table>
<h6>Falha no Participante</h6>
<p><span class="arithmatex">\(P\)</span> consegue saber o que fazer após se recuperar da falha no estado READY ou PRE-COMMIT</p>
<ul>
<li>Participantes e coordenador não distam mais que um estado.</li>
<li>Se alguém em READY, o coordenador não mandou global-commit ainda; Aborte.</li>
<li>Se <em>todos</em> em PRE-COMMIT, é possível comitar, comite.</li>
<li>A execução dos passos anteriores tem que anular o poder do coordenador.</li>
</ul>
<p><em>Se todos os participantes em READY?</em></p>
<h6>3PC x 2PC</h6>
<ul>
<li>3PC -- Aumenta disponibilidade</li>
<li>2PC -- Falha do coordenador é "corner case"</li>
<li>3PC -- Aumenta o custo do "caminho feliz" e por isso não é usado na prática</li>
<li>Nenhum escala e não usá-los é uma das razões para o surgimento dos sistemas NoSQL</li>
</ul>
<h4 id="paxos-commit">Paxos-Commit</h4>
<p>Usa instâncias de Consenso Distribuído para votar. Se o consenso é tolerante a falhas e consistente, todos vêem o mesmo resultado na transação.</p>
<h6>O protocolo</h6>
<ul>
<li>Para terminar a transação <span class="arithmatex">\(T\)</span>, o coordenador envia request-commit a todos os participantes.</li>
<li>Um participante <span class="arithmatex">\(P\)</span> propõe seu voto na instância <span class="arithmatex">\(T_P\)</span> de consenso.</li>
<li>
<p>Todo participante <span class="arithmatex">\(P\)</span> espera pelas decisões das instâncias de consenso <span class="arithmatex">\(T_i\)</span> para todos os participantes <span class="arithmatex">\(i\)</span>, inclusive si mesmo; se todas as decisões forem commit, o participante comita a transação.</p>
</li>
<li>
<p>Se cansar de esperar por <span class="arithmatex">\(T_Q\)</span>, o participante propõe abort em <span class="arithmatex">\(T_Q\)</span>.</p>
</li>
</ul>
<h6>Falha no Participante</h6>
<ul>
<li>Se o participante falha antes de votar, então alguém votará abort por ele.</li>
<li>Se o participante <span class="arithmatex">\(P\)</span> falha, ou é suspeito de, então é possível que dois votos diferentes tenham sido propostos em <span class="arithmatex">\(T_P\)</span>; isso não é um problema pois a decisão é a mesma para todos observando a instância.</li>
<li>Após se recuperar, o participante recupera as decisões de todas as instâncias <span class="arithmatex">\(T_i\)</span> e termina apropriadamente.</li>
</ul>
<h2 id="log-structured-merge-trees">Log Structured Merge Trees</h2>
<p>Idealmente, toda manipulação de dados seria executada a partir da memória principal, tendo assim a menor latência possível.
Contudo, para que se tenha também durabilidade das operações executadas, para que os dados manipulados sobrevivam a reinicializações do servidor, intencionais ou não, é preciso armazenar os dados em <strong>memória estável</strong>, da qual a mais comum são os <strong>discos rígidos</strong>.
Bancos de dados relacionais tradicionalmente armazenam seus dados em disco usando estruturas em árvore, pois estas tem custo amortizado de leitura e escrita <span class="arithmatex">\(O(log n)\)</span>.
Bancos de dados NoSQL, muito usados em cenários de <em>Big Data</em>, em  que quantidades muito grandes de dados são geradas e acessadas com grande velocidade, capitanearam um esforço para otimizar operações de escrita enquanto também tentando não aumentar significativamente os tempos de leitura.</p>
<p>É notório que operações em disco são muito mais lentas que em memória principal, mas o que exatamente é lento no acesso ao disco?
Essencialmente, o posicionamento da cabeca de leitura/escrita na trilha correta do disco, pois esta operação é mecânica.
Por esta razão, acessos aleatórios são mais custosos que acessos sequenciais, pois neste o custo de posicionamento é pago apenas uma vez.
Alguns bancos de dados, como o Cassandra, armazenam os dados na forma de uma <strong><em>Log Structured Merge Tree</em></strong>, ou LSMT, que acessa o disco quase que exclusivamente de forma sequencial, minimizando assim o impacto da durabilidade no desempenho do sistema.</p>
<p>Considere um banco armazenando uma pequena quantidade de dados, que cabe em memória principal
Usando LSMT, os dados são mantidos em memória principal em estruturas de dados denominadas <em>memory table</em>, ou simplesmente <strong>memtables</strong>.
Operações de escrita são "logadas" e um <strong><em>commit log</em></strong>, em disco, antes de serem aplicadas às memtables e confirmadas para o cliente.
Neste cenário o acesso ao disco na escrita é sequencial, o melhor que se pode ter em um disco, e a recuperação dos dados é feita diretamente da memória, rapidamente.</p>
<p><img alt="LSMT" src="../drawings/lsmt.drawio-0.svg" /></p>
<p>No caso de uma reinicialização do processo, a reexecução do <em>commit log</em> restaurará o estado da memtable.</p>
<p><img alt="LSMT" src="../drawings/lsmt.drawio-1.svg" /></p>
<p>Observe que a leitura do <em>commit log</em> é sequencial, o que acelera a reexecução.
Ainda assim, se o <em>commit log</em> for extenso, reexecutá-lo demandará um tempo significativo.
Uma forma de acelerar o processo é fazer <strong><em>snapshots</em></strong> da memtable de forma sincronizada com a escrita no log.
Isto é, digamos que todas as operações de escrita, até a décima, estão salvas no commit log e refletidas na memtable.
Digamos também que todas as operações são modificações da mesma linha do banco de dados em memória.
Se um <em>snapshot</em>  é tomado, ele será correspondente ao commit log, isto é, conterá o efeito de exatamente as mesmas 10 operações, mas de forma mais compacta que o log, uma vez que o log conterá dez operações e o snapshot somente uma linha de dados.</p>
<p><img alt="LSMT" src="../drawings/lsmt.drawio-2.svg" /></p>
<p>Após o snapshot ser concluído, o log correspondente pode ser apagado, assim como snapshots anteriores.</p>
<p><img alt="LSMT" src="../drawings/lsmt.drawio-3.svg" /></p>
<p>Novas operações de escrita devem ser armazenadas em um novo log e, no caso de uma reinicialização, primeiro se deve restaurar o <em>snapshot</em> e então o novo log.</p>
<p><img alt="LSMT" src="../drawings/lsmt.drawio-4.svg" /></p>
<p>Para lidar com corrupções de arquivo no sistema, pode ser uma boa ideia manter mais do que o último log e <em>snapshot</em>, já que a recuperação do estado exigiria voltar mais atrás na reexecução de operações.</p>
<p>Observe que, além da escrita dos logs, todos os outros acessos ao disco também são sequenciais, seja o <em>flush</em> das memtables, ou a leitura dos snapshots para recuperação e do commit log para reexecução e, já que operações de leitura são todas respondidas da memória, o sistema terá um excelente desempenho.
Contudo, há outro limitante de desempenho importante, relacionado à premissa pouco realista de que os dados cabem todos em memória. 
Isto é, se os dados não cabem em memória, <em>snapshots</em>  serão importantes não somente para permitir coletar lixo dos logs, isto é, dados obsoletos, mas também, para usar a capacidade de armazenamento dos discos.</p>
<p>Consideremos então um cenário em que a memtable cabe apenas <em>n</em> entradas; quando a operação para adicionar <span class="arithmatex">\(n+1\)</span>-ésima entrada à memtable é recebida, um <strong><em>flushs</em></strong> dos dados para um novo <em>snapshot</em> é feito e a memtable é <em>resetada</em>, liberando espaço em memória. Para melhorar o desempenho, estas descargas podem ser feitas proativamente antes da chegada de novas entradas e fora do <em>caminho crítico</em> da operação de escrita, mas isto é apenas uma otimização e portanto não a consideraremos aqui.</p>
<p><img alt="LSMT" src="../drawings/lsmt.drawio-5.svg" /></p>
<p>Neste novo fluxo, os arquivos em disco não correspondem mais a <em>snapshots</em> do banco de dados mas a porções dos dados, então nos referiremos a eles como <em>stable storage tables</em>, ou <strong>sstables</strong>, em oposição às <em>memtables</em>, pelo menos por enquanto.</p>
<h5 id="compactacoes">Compactações</h5>
<p>Apesar deste novo fluxo de escrita aumentar a capacidade de armazenamento do nosso banco de dados, ele traz problemas para o fluxo de leitura.
Digamos que a chave <span class="arithmatex">\(k\)</span> teve um valor atribuído e descarregado em uma sstable em diversas ocasiões.
O primeiro problema aqui é que há vários valores antigos associados a <span class="arithmatex">\(k\)</span>, inutilmente e ocupando espaço, isto é, lixo.</p>
<p><img alt="LSMT" src="../drawings/lsmt.drawio-6.svg" /></p>
<p>O segundo é que caso o valor associado a <span class="arithmatex">\(k\)</span> seja requisitado, o sistema deverá retornar a última versão, que pode estar em diversos arquivos.
Para lidar com ambos os problemas, podemos <strong>compactar</strong> as sstables juntas, eliminados dados obsoletos e minimizando o número de arquivos a serem pesquisados no caso de leitura.
Caso a sstables estejam ordenadas, o procedimento de compactação pode ser feito como a união de dois segmentos de dados no <em>merge sort</em>, isto é, iterando-se paralelamente nos dois arquivos e escolhendo sempre a menor chave da vez e movendo-a para um novo segmento que conterá a união dos dados.</p>
<p><img alt="LSMT" src="../drawings/lsmt.drawio-7.svg" /></p>
<p>A figura a seguir mostra um exemplo que várias sstables de nível 0, aquelas geradas por <em>flushs</em>, são unidas gerando sstables de nível 1 e assim sucessivamente.
Observe como as compactações geram uma árvore (na verdade, uma floresta), razão do nome <em>merge tree</em>.</p>
<p><img alt="https://www.hedvig.io/blog/hedvig-internals-log-structured-merge-trees-and-folding-of-bloom-filters" src="../images/lsm_compac.png" /></p>
<p>No caso de uma leitura, somente as tabelas mais à direita e de nível mais alto precisam ser consultadas e portanto as sstables já usadas como entrada podem ser eliminadas como lixo do sistema.
<strong>Ainda assim</strong>, no caso de uma leitura, diversas sstables potencialmente contém o dado a ser retornado.
O problema se agrava em sistemas em que partes do dado possam ser gravadas independentemente, como no CassandraDB, em que cada coluna é independente das outras.
Diversas propostas poderiam ser feitas para se <strong>identificar mais rapidamente se uma sstable contém uma chave</strong>.</p>
<p>Por exemplo, pode-se associar a cada tabela um bitmap indicando a presença ou não de uma certa chave, mas esta abordagem obviamente falha se o espaço de chaves for grande.
Outra possibilidade é lembrar a faixa de chaves contida na tabela. Esta estratégia pode ser útil caso haja localidade no espaço de chaves no momento da escrita, mas falhará miseravelmente se o espaço de chaves for usado uniformemente, resultando em faixas grandes entre a menor e maior chaves de cada tabela.
Como acelerar a identificação das sstables pertinentes? 
Entram em cena os filtros de <strong>Bloom</strong>.</p>
<h3 id="filtros-de-bloom">Filtros de Bloom</h3>
<p>De acordo com nossa fonte mais que confiável, a <a href="https://en.wikipedia.org/wiki/Bloom_filter">Wikipedia</a></p>
<div class="admonition quote">
<p class="admonition-title">Bloom Filter</p>
<p>A Bloom filter is a <strong><em>space-efficient probabilistic</em></strong> data structure, conceived by Burton Howard <em>Bloom</em> in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not, thus a Bloom filter has a 100% recall rate. In other words, a query returns either <strong>"possibly in set"</strong> or <strong>"definitely not in set"</strong>.</p>
</div>
<p>Se associarmos a cada sstable um filtro de Bloom, então só será preciso lê-la se o filtro correspondente disser que a chave possivelmente está contida, como no seguinte exemplo.</p>
<p><img alt="LSMT+Bloom Filter" src="../images/bf_lsm.jpg" /></p>
<p>Mas como exatamente construímos um filtro de Bloom?
Iniciamos com um <strong>vetor de bits inicialmente zerados</strong> e um conjunto finito de <strong>funções de hash</strong> cujo resultado seja uniformemente distribuído no tamanho do vetor de bits.
Para cada elemento colocado no conjunto a ser refletido pelo filtro, aplicamos cada uma das funções hash e colocamos o <strong>bit 1 na posição do vetor igual ao resultado da função</strong>.
No exemplo a seguir, inserimos os elementos x, y e z e usamos três funções hash.</p>
<p><img alt="By David Eppstein" src="../images/bf.png" /></p>
<p>Na <strong>consulta</strong>, cada elemento passa por pelas mesmas funções hash para identificar quais bits do vetor ler.
Se algum dos índices apontados não estiver com um 1, como no caso do c, no exemplo, o elemento não pertence ao conjunto.
Caso contrário, o filtro responderá que é possível que pertença.</p>
<p>Mas quão bom é um filtro de Bloom na identificação do das sstables?
O filtro será melhor se os bits 1 forem devidos a menos elementos mapeando para tal posição, pois se muitos elementos mapearem para a mesma posição, falsos positivos podem ocorrer.
Assim, de outra forma, quais fatores influenciam na taxa de falsos positivos do filtro?</p>
<ul>
<li>o número <span class="arithmatex">\(n\)</span> de elementos no conjunto, uma vez que quanto mais elementos, mais bits  1 no vetor;</li>
<li>o número <span class="arithmatex">\(k\)</span> de hashes, pois quanto mais hashes, mais bits transformados em 1; e,</li>
<li>o número <span class="arithmatex">\(m\)</span> de bits no vetor, pois quanto menos bits, mais colisões de bits.</li>
</ul>
<p>De forma mais precisa,</p>
<ul>
<li>a probabilidade de setar um certo bit na inserção de um elemento é <span class="arithmatex">\(1/m\)</span>, e</li>
<li>a probabilidade de não setar tal bit é <span class="arithmatex">\(1 - 1/m\)</span>;</li>
<li>a probabilidade de <span class="arithmatex">\(k\)</span> hashes não setarem um bit é <span class="arithmatex">\((1 - 1/m)^k\)</span>;</li>
<li>a probabilidade de não setar um bit após <span class="arithmatex">\(n\)</span> inserções é <span class="arithmatex">\((1 - 1/m)^{kn}\)</span>;</li>
<li>a probabilidade de setar um bit após <span class="arithmatex">\(n\)</span> inserções é <span class="arithmatex">\(1 - (1 - 1/m)^{kn}\)</span></li>
</ul>
<p>Logo,</p>
<ul>
<li>a probabilidade de falso positivo <span class="arithmatex">\(p = (1 - (1 - 1/m)^{kn})^k \approx (1 - e^{-kn/m})^k\)</span>
O que nos permite chegar à relação</li>
<li><span class="arithmatex">\(m/n = - 1.44\log_2 p\)</span>, em que podemos calcular <span class="arithmatex">\(m\)</span> em função do <span class="arithmatex">\(n\)</span> esperado e do <span class="arithmatex">\(p\)</span> desejado.
E podemos também identificar o <span class="arithmatex">\(k\)</span> ótimo para a situação, pela equação</li>
<li><span class="arithmatex">\(k = - \frac{\ln p}{\ln 2} = - \log_2 p\)</span></li>
</ul>
<p>Uma forma "simples" de visualizar este resultado é dada pela figura a seguir, em que o eixo Y dá a taxa de falsos positivos do filtro em função do número de elementos inseridos, indicado no eixo X, para diversas configurações, apresentadas como curvas.
Por exemplo, com um filtro com <span class="arithmatex">\(m = 2^{24}b = 2MB\)</span>, após 1 milhão de inserções, tem-se probabilidade de falsos positivo <span class="arithmatex">\(p = 0,0001\)</span>.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Combinar</p>
<ul>
<li><a href="https://adambcomer.com/blog/simple-database/motivation-design.html">https://adambcomer.com/blog/simple-database/motivation-design.html</a></li>
<li><a href="https://adambcomer.com/blog/simple-database/memtable.html">https://adambcomer.com/blog/simple-database/memtable.html</a></li>
<li><a href="https://adambcomer.com/blog/simple-database/wal.html">https://adambcomer.com/blog/simple-database/wal.html</a></li>
<li><a href="https://www.jasondavies.com/bloomfilter/">https://www.jasondavies.com/bloomfilter/</a></li>
</ul>
</div>
<h2 id="cap">CAP</h2>
<details class="todo"><summary>TODO</summary><p>Incluir explicação</p>
</details>
<h2 id="referencias">Referências</h2>
<ul>
<li><a href="https://cloud.google.com/datastore/docs/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore/">Balancing Strong and Eventual Consistency with Datastore</a></li>
<li><a href="https://blog.yugabyte.com/a-primer-on-acid-transactions/">https://blog.yugabyte.com/a-primer-on-acid-transactions/</a></li>
<li><a href="https://jepsen.io/consistency">https://jepsen.io/consistency</a></li>
<li><a href="https://fauna.com/blog/demystifying-database-systems-part-4-isolation-levels-vs-consistency-levels">https://fauna.com/blog/demystifying-database-systems-part-4-isolation-levels-vs-consistency-levels</a></li>
<li><a href="https://www.postgresql.org/docs/9.5/transaction-iso.html">https://www.postgresql.org/docs/9.5/transaction-iso.html</a></li>
<li>Inspirado nas notas de aula de Johan Montelius e Vladimir Vlassov, da disciplina ID2201 Distributed Systems, KTH Royal Institute of Technology. Imagens copiadas descaradamente de seus slides em <a href="https://www.kth.se/social/files/57c2cbd7f276541680e39e6d/transactions.pdf">https://www.kth.se/social/files/57c2cbd7f276541680e39e6d/transactions.pdf</a></li>
<li><a href="https://www.cs.ucy.ac.cy/~dzeina/courses/epl446/lectures/16.pdf">https://www.cs.ucy.ac.cy/~dzeina/courses/epl446/lectures/16.pdf</a></li>
<li><a href="https://www.cs.princeton.edu/courses/archive/fall18/cos418/docs/p8-consistency.pdf">https://www.cs.princeton.edu/courses/archive/fall18/cos418/docs/p8-consistency.pdf</a></li>
<li><a href="https://aphyr.com/posts/313-strong-consistency-models">https://aphyr.com/posts/313-strong-consistency-models</a> </li>
<li><a href="http://www.slideshare.net/quipo/modern-algorithms-and-data-structures-1-bloom-filters-merkle-trees">Modern Algorithms and Data Structures: Bloom-Filter</a></li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:cons">
<p>Consistência no sentido visto no capítulo anterior, não no sentido ACID.&#160;<a class="footnote-backref" href="#fnref:cons" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:atu">
<p>Na prática, a atualização consiste apenas em mudar um ponteiro para apontar para a cópia privada.&#160;<a class="footnote-backref" href="#fnref:atu" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:kth">
<p>Baseado no material disponível em <a href="https://www.kth.se/social/course/ID2201/">Distributed Systems, Basic Course</a>.&#160;<a class="footnote-backref" href="#fnref:kth" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div>

  <!-- Last update of source file -->


              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href="../consistency/" class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Anterior
              </span>
              Consistência
            </div>
          </div>
        </a>
      
      
        <a href="../disfs/" class="md-footer__link md-footer__link--next" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Próximo
              </span>
              Sistemas de Arquivos
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": [], "translations": {"clipboard.copy": "Copiar para \u00e1rea de transfer\u00eancia", "clipboard.copied": "Copiado para \u00e1rea de transfer\u00eancia", "search.config.lang": "pt", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Buscar", "search.result.placeholder": "Digite para iniciar a busca", "search.result.none": "Nenhum resultado encontrado", "search.result.one": "1 resultado encontrado", "search.result.other": "# resultados encontrados", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../assets/javascripts/workers/search.fe42c31b.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.4ea5477f.min.js"></script>
      
        <script src="https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../javascripts/mathjaxhelper.js"></script>
      
    
  </body>
</html>